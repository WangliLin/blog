{"meta":{"title":"Wangli's Blog","subtitle":null,"description":null,"author":"Wangli Lin","url":"wanglilin.github.io"},"pages":[{"title":"Categories","date":"2017-03-01T08:36:45.544Z","updated":"2017-03-01T08:36:45.544Z","comments":true,"path":"categories/index.html","permalink":"wanglilin.github.io/categories/index.html","excerpt":"","text":""},{"title":"About","date":"2017-03-01T08:36:45.544Z","updated":"2017-03-01T08:36:45.544Z","comments":true,"path":"about/index.html","permalink":"wanglilin.github.io/about/index.html","excerpt":"","text":""},{"title":"Tags","date":"2017-03-01T08:36:45.544Z","updated":"2017-03-01T08:36:45.544Z","comments":true,"path":"tags/index.html","permalink":"wanglilin.github.io/tags/index.html","excerpt":"","text":""},{"title":"","date":"2017-03-20T10:07:34.222Z","updated":"2017-03-20T10:07:34.222Z","comments":false,"path":"/404.html","permalink":"wanglilin.github.io//404.html","excerpt":"","text":""}],"posts":[{"title":"SQL典型例题总结","slug":"sql-1","date":"2018-04-04T04:16:05.000Z","updated":"2018-04-04T04:22:31.944Z","comments":true,"path":"2018/04/04/sql-1/","link":"","permalink":"wanglilin.github.io/blog/2018/04/04/sql-1/","excerpt":"1. 统计出当前各个title类型对应的员工当前薪水对应的平均工资。表结构：1234567891011CREATE TABLE `salaries` (`emp_no` int(11) NOT NULL,`salary` int(11) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`from_date`));CREATE TABLE IF NOT EXISTS \"titles\" (`emp_no` int(11) NOT NULL,`title` varchar(50) NOT NULL,`from_date` date NOT NULL,`to_date` date DEFAULT NULL); 思路： INNER JOIN的使用 GROUP BY + AVG( )的使用","text":"1. 统计出当前各个title类型对应的员工当前薪水对应的平均工资。表结构：1234567891011CREATE TABLE `salaries` (`emp_no` int(11) NOT NULL,`salary` int(11) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`from_date`));CREATE TABLE IF NOT EXISTS \"titles\" (`emp_no` int(11) NOT NULL,`title` varchar(50) NOT NULL,`from_date` date NOT NULL,`to_date` date DEFAULT NULL); 思路： INNER JOIN的使用 GROUP BY + AVG( )的使用 代码：12345SELECT titles.title AS title, AVG(salaries.salary) AS avgFROM titlesINNER JOIN salariesON salaries.emp_no = titles.emp_no AND salaries.to_date = titles.to_date AND salaries.to_date = '9999-01-01'GROUP BY titles.title; 2. 获取当前（to_date=’9999-01-01’）薪水第二多的员工的emp_no以及其对应的薪水salary表结构：123456CREATE TABLE `salaries` (`emp_no` int(11) NOT NULL,`salary` int(11) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`from_date`)); 思路： distinct 和 limit的使用 代码：1234567-- 第一种解法SELECT emp_no, max(salary) FROM salariesWHERE salary &lt; (SELECT MAX(SALARY) FROM salaries) and to_date = '9999-01-01';--第二种解法select emp_no, salary from salarieswhere to_date = '9999-01-01' and salary = (select distinct salary from salaries order by salary desc limit 1,1) 3. 查找所有员工的last_name和first_name以及对应的dept_name，也包括暂时没有分配部门的员工表结构：1234567891011121314151617181920CREATE TABLE `departments` (`dept_no` char(4) NOT NULL,`dept_name` varchar(40) NOT NULL,PRIMARY KEY (`dept_no`));CREATE TABLE `dept_emp` (`emp_no` int(11) NOT NULL,`dept_no` char(4) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`dept_no`));CREATE TABLE `employees` (`emp_no` int(11) NOT NULL,`birth_date` date NOT NULL,`first_name` varchar(14) NOT NULL,`last_name` varchar(16) NOT NULL,`gender` char(1) NOT NULL,`hire_date` date NOT NULL,PRIMARY KEY (`emp_no`)); 思路： left join + 三表联合查询 代码：123SELECT employees.last_name, employees.first_name, departments.dept_name FROM (employees LEFT JOIN dept_emp ON employees.emp_no = dept_emp.emp_no)LEFT JOIN departments ON dept_emp.dept_no = departments.dept_no; 4. 查找所有员工自入职以来的薪水涨幅情况，给出员工编号emp_noy以及其对应的薪水涨幅growth，并按照growth进行升序表结构：123456789101112131415CREATE TABLE `employees` (`emp_no` int(11) NOT NULL,`birth_date` date NOT NULL,`first_name` varchar(14) NOT NULL,`last_name` varchar(16) NOT NULL,`gender` char(1) NOT NULL,`hire_date` date NOT NULL,PRIMARY KEY (`emp_no`));CREATE TABLE `salaries` (`emp_no` int(11) NOT NULL,`salary` int(11) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`from_date`)); 思路： 看清题意~~ b表为当前工资，c表为入职工资 代码：12345678select a.emp_no, (b.salary - c.salary) as growthfrom employees as a inner join salaries as b on a.emp_no = b.emp_no and b.to_date = '9999-01-01' inner join salaries as c on a.emp_no = c.emp_no and a.hire_date = c.from_dateorder by growth asc;","categories":[{"name":"SQL","slug":"SQL","permalink":"wanglilin.github.io/categories/SQL/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"wanglilin.github.io/tags/SQL/"}]},{"title":"连续特征离散化的优点","slug":"continuous-discretization","date":"2018-04-01T07:47:52.000Z","updated":"2018-04-01T07:55:48.885Z","comments":true,"path":"2018/04/01/continuous-discretization/","link":"","permalink":"wanglilin.github.io/blog/2018/04/01/continuous-discretization/","excerpt":"模型是使用离散特征还是连续特征，其实是一个“海量离散特征 + 简单模型” 同 “少量连续特征 + 复杂模型”的权衡，既可以离散化用线性模型，也可以用连续特征加深度学习。就看是喜欢折腾特征还是喜欢折腾模型了。通常来说，前者容易，可以n个人一起并行做，有成功经验；后者目前看起来很赞，能走多远还需拭目以待。 ——李沐 在CTR预估中，通常都会用到离散特征特征 + LR，很少直接将连续值作为逻辑回归模型的特征输入，而是将连续特征离散化为一系列0、1类别特征交给逻辑回归模型，这样做的优势主要有以下几点：","text":"模型是使用离散特征还是连续特征，其实是一个“海量离散特征 + 简单模型” 同 “少量连续特征 + 复杂模型”的权衡，既可以离散化用线性模型，也可以用连续特征加深度学习。就看是喜欢折腾特征还是喜欢折腾模型了。通常来说，前者容易，可以n个人一起并行做，有成功经验；后者目前看起来很赞，能走多远还需拭目以待。 ——李沐 在CTR预估中，通常都会用到离散特征特征 + LR，很少直接将连续值作为逻辑回归模型的特征输入，而是将连续特征离散化为一系列0、1类别特征交给逻辑回归模型，这样做的优势主要有以下几点： 离散特征的增加和减少都很容易，易于模型的快速迭代。 稀疏向量内积乘法运算速度快，计算结果方便存储，容易扩展； 离散化后的特征对异常数据具有很强的鲁棒性； 逻辑回归属于广义线性模型，表达能力有限；单变量离散化为N个后，每个变量有单独的权重，相当于为模型引入了非线性能力，能够提升模型的表达能力： 加大拟合：在LR模型中，特征A作为连续特征对应的权重是Wa。A是线性特征，因为y = Wa*A,y对于A的导数就是Wa,如果离散化后，A按区间离散化为A_1,A_2,A_3。那么y = w_1*A_1+w_2*A_2+w_3*A_3.那么y对于A的函数就相当于分段的线性函数，y对于A的导数也随A的取值变动，所以，相当于引入了非线性。 防止过拟合：当使用连续特征时，一个特征对应于一个权重，那么，如果这个特征权重较大，模型就会很依赖于这个特征，这个特征的一个微小变化可能会导致最终结果产生很大的变化，这样子的模型很危险，当遇到新样本的时候很可能因为对这个特征过分敏感而得到错误的分类结果，也就是泛化能力差，容易过拟合。而使用离散特征的时候，一个特征变成了多个，权重也变为多个，那么之前连续特征对模型的影响力就被分散弱化了，从而降低了过拟合的风险。 离散化后进行特征交叉，加入特征A离散化为M个值，特征B离散为N个值，那么交叉之后会有M*N个变量，进一步引入非线性，提升表达能力； 特征离散化后，模型更稳定，比如如果对用户年龄离散化，20-30作为一个区间，不会因为一个用户年龄长了一岁就变成一个完成不同的人，当然，需要注意的是，如何合理的划分区间。 离散方法等距离散取值范围均匀划成n等份，每份的间距相等 等频离散均匀分为n等份，每份内包含的观察点数相同 优化离散大致有两类方法： 卡方检验方法：（统计样本的实际观测值与理论推断值之间的偏离程度，卡方值越大，越不符合；卡方值越小，偏差越小，越趋于符合） 分裂方法：找到一个分裂点看，左右2个区间，在目标值上分布是否有- 显著差异，有显著差异就分裂，否则就忽略。这个点可以每次找差异最大的点 合并方法：先划分如果很小单元区间，按顺序合并在目标值上分布不显著的相邻区间，直到收敛 信息增益方法： 分裂方法：找到一个分裂点看，左右2个区间，看分裂前后信息增益变化阈值，如果差值超过阈值（正值，分列前-分裂后信息熵），则分裂。每次找差值最大的点做分裂点，直到收敛 合并方法：先划分 如果很小单元区间，按顺序合并信息增益小于阈值的相邻区间，直到收敛","categories":[{"name":"机器学习","slug":"机器学习","permalink":"wanglilin.github.io/categories/机器学习/"}],"tags":[{"name":"特征工程","slug":"特征工程","permalink":"wanglilin.github.io/tags/特征工程/"},{"name":"机器学习","slug":"机器学习","permalink":"wanglilin.github.io/tags/机器学习/"}]},{"title":"高频面试题总结之带重复元素的排列","slug":"permutations","date":"2018-04-01T07:41:24.000Z","updated":"2018-04-01T07:43:41.884Z","comments":true,"path":"2018/04/01/permutations/","link":"","permalink":"wanglilin.github.io/blog/2018/04/01/permutations/","excerpt":"题目详情LintCode No.16 给出一个具有重复数字的列表，找出列表所有不同的排列。 样例给出列表 [1,2,2]，不同的排列有：[ [1,2,2], [2,1,2], [2,2,1] ]","text":"题目详情LintCode No.16 给出一个具有重复数字的列表，找出列表所有不同的排列。 样例给出列表 [1,2,2]，不同的排列有：[ [1,2,2], [2,1,2], [2,2,1] ] 思路：回溯法 + 判断语句即可 12345678for (int i = 0; i &lt; nums.length; i++) &#123; //判断语句 if (visited[i] == 1 || (i != 0 &amp;&amp; nums[i] == nums[i-1] &amp;&amp; visited[i-1] == 0)) continue; //回溯 &#125; 上面的判断主要是为了去除重复元素影响。比如，给出一个排好序的数组，[1,2,2]，那么第一个2和第二2如果在结果中互换位置，我们也认为是同一种方案，所以我们强制要求相同的数字，原来排在前面的，在结果当中也应该排在前面，这样就保证了唯一性。所以当前面的2还没有使用的时候，就 不应该让后面的2使用。 代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class Solution &#123; /* * @param : A list of integers * @return: A list of unique permutations */ public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) &#123; // write your code here ArrayList&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;List&lt;Integer&gt;&gt;(); List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); if (nums == null) &#123; return result; &#125; if(nums.length == 0) &#123; result.add(new ArrayList&lt;Integer&gt;()); return result; &#125; Arrays.sort(nums); int[] visited = new int[nums.length]; for (int i = 0; i &lt; nums.length; i++) &#123; visited[i] = 0; &#125; helper(result, list, nums, visited); return result; &#125; private void helper(ArrayList&lt;List&lt;Integer&gt;&gt; result, List&lt;Integer&gt; list, int[] nums, int[] visited) &#123; if (list.size() == nums.length) &#123; result.add(new ArrayList&lt;Integer&gt;(list)); return; &#125; for (int i = 0; i &lt; nums.length; i++) &#123; if (visited[i] == 1 || (i != 0 &amp;&amp; nums[i] == nums[i-1] &amp;&amp; visited[i-1] == 0)) continue; list.add(nums[i]); visited[i] = 1; helper(result, list, nums, visited); visited[i] = 0; list.remove(list.size() - 1); &#125; &#125; &#125;;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"wanglilin.github.io/categories/数据结构/"}],"tags":[{"name":"高频面试题总结","slug":"高频面试题总结","permalink":"wanglilin.github.io/tags/高频面试题总结/"},{"name":"数据结构","slug":"数据结构","permalink":"wanglilin.github.io/tags/数据结构/"}]},{"title":"高频面试题总结之最长上升子序列","slug":"longest-inceasing-subsequence","date":"2018-03-31T14:00:59.000Z","updated":"2018-03-31T14:04:39.423Z","comments":true,"path":"2018/03/31/longest-inceasing-subsequence/","link":"","permalink":"wanglilin.github.io/blog/2018/03/31/longest-inceasing-subsequence/","excerpt":"题目详情LintCode No.76 给定一个整数序列，找到最长上升子序列（LIS），返回LIS的长度。 最长上升子序列的定义：最长上升子序列问题是在一个无序的给定序列中找到一个尽可能长的由低到高排列的子序列，这种子序列不一定是连续的或者唯一的。 样例给出 [5,4,1,2,3]，LIS 是 [1,2,3]，返回 3给出 [4,2,4,5,3,7]，LIS 是 [2,4,5,7]，返回 4","text":"题目详情LintCode No.76 给定一个整数序列，找到最长上升子序列（LIS），返回LIS的长度。 最长上升子序列的定义：最长上升子序列问题是在一个无序的给定序列中找到一个尽可能长的由低到高排列的子序列，这种子序列不一定是连续的或者唯一的。 样例给出 [5,4,1,2,3]，LIS 是 [1,2,3]，返回 3给出 [4,2,4,5,3,7]，LIS 是 [2,4,5,7]，返回 4 解法1 动态规划思路： 两个for循环遍历数组：1234567for (int i = 1; i &lt; nums.length; i++) &#123; for (int j = 0; j &lt; i; j++) &#123; if(nums[i] &gt; nums[j]) &#123; dp[i] = Math.max(dp[j] + 1, dp[i]); &#125; &#125; &#125; 状态转移：dp[i] = Math.max(dp[j] + 1, dp[i])时间复杂度：O(n^2) 完整代码如下：1234567891011121314151617181920212223public int longestIncreasingSubsequence(int[] nums) &#123; // write your code here if(nums.length == 0) &#123; return 0; &#125; int[] dp = new int[nums.length]; for (int i = 0; i &lt; nums.length; i++) &#123; dp[i] = 1; &#125; for (int i = 1; i &lt; nums.length; i++) &#123; for (int j = 0; j &lt; i; j++) &#123; if(nums[i] &gt; nums[j]) &#123; dp[i] = Math.max(dp[j] + 1, dp[i]); &#125; &#125; &#125; Arrays.sort(dp); return dp[nums.length-1]; &#125; 可以尝试使用二分查找来优化，具体思路如下： 建个数组，令数组中的每个数的值都为Integer.MAX_VALUE 从题目所给序列中，依次取出每个值，更新数组 更新数组的规则为：找到第一个大于取出值的数组元素，替代其值 最后，从后往前对数组进行遍历，找到第一个非Integer.MAX_VALUE的数组元素的index即为我们所求的结果。 完整代码如下：123456789101112131415161718192021222324252627282930313233343536public int longestIncreasingSubsequence(int[] nums) &#123; int[] minLast = new int[nums.length + 1]; minLast[0] = Integer.MIN_VALUE; for (int i = 1; i &lt;= nums.length; i++) &#123; minLast[i] = Integer.MAX_VALUE; &#125; for (int i = 0; i &lt; nums.length; i++) &#123; // find the first number in minLast &gt;= nums[i] int index = binarySearch(minLast, nums[i]); minLast[index] = nums[i]; &#125; for (int i = nums.length; i &gt;= 1; i--) &#123; if (minLast[i] != Integer.MAX_VALUE) &#123; return i; &#125; &#125; return 0; &#125; // find the first number &gt; num private int binarySearch(int[] minLast, int num) &#123; int start = 0, end = minLast.length - 1; while (start &lt;= end) &#123; int mid = ((end - start) &gt;&gt; 1) + start; if (minLast[mid] &lt; num) &#123; start = mid + 1; &#125; else &#123; end = mid - 1; &#125; &#125; return end + 1; &#125; 时间复杂度为O(nlogn)，相比动规，做到了一定程度上的优化。","categories":[{"name":"数据结构","slug":"数据结构","permalink":"wanglilin.github.io/categories/数据结构/"}],"tags":[{"name":"高频面试题总结","slug":"高频面试题总结","permalink":"wanglilin.github.io/tags/高频面试题总结/"},{"name":"数据结构","slug":"数据结构","permalink":"wanglilin.github.io/tags/数据结构/"}]},{"title":"高频面试题之二分查找","slug":"binarysearch","date":"2018-03-31T09:56:25.000Z","updated":"2018-03-31T10:01:06.176Z","comments":true,"path":"2018/03/31/binarysearch/","link":"","permalink":"wanglilin.github.io/blog/2018/03/31/binarysearch/","excerpt":"二分查找二三事引言华为综合面碰到一个Cloud BU的大佬，唉，我明明面的是算法岗，这位大佬死抓我没有计算机基础不放，先是针对进程和线程死磕，而后怀疑我的开发水平，最后让我白板写二分查找，第一次白板写代码，很简单的题目，觉得最重要的是理清思路，先写个代码流程图再动手写代码相对会好点，以后面试再遇到白板编程就这么干吧，那天虽然把整体思路都理出来了，也写了个大概，但觉得还是不熟练，还是想复习下二分查找，二分查找说是简单，但其中关于边界的处理其实需要一波思考。这篇文章主要以一道lintcode题目，引发对二分查找的边界值的思考，以及一些变形题的实现，好吧，废话不多说，让我们开始吧…","text":"二分查找二三事引言华为综合面碰到一个Cloud BU的大佬，唉，我明明面的是算法岗，这位大佬死抓我没有计算机基础不放，先是针对进程和线程死磕，而后怀疑我的开发水平，最后让我白板写二分查找，第一次白板写代码，很简单的题目，觉得最重要的是理清思路，先写个代码流程图再动手写代码相对会好点，以后面试再遇到白板编程就这么干吧，那天虽然把整体思路都理出来了，也写了个大概，但觉得还是不熟练，还是想复习下二分查找，二分查找说是简单，但其中关于边界的处理其实需要一波思考。这篇文章主要以一道lintcode题目，引发对二分查找的边界值的思考，以及一些变形题的实现，好吧，废话不多说，让我们开始吧… 一道LintCode题引发的思考 Guess Number GameWe are playing the Guess Game. The game is as follows:I pick a number from 1 to n. You have to guess which number I picked.Every time you guess wrong, I’ll tell you whether the number is higher or lower.You call a pre-defined API guess(int num) which returns 3 possible results (-1, 1, or 0): 样例n = 10, I pick 4 (but you don’t know)Return 4. Correct ! 思路：一开始觉得这就是普通的二分查找问题，便写出如下代码： 12345678910111213141516171819202122232425262728293031/* The guess API is defined in the parent class GuessGame. @param num, your guess @return -1 if my number is lower, 1 if my number is higher, otherwise return 0 int guess(int num); */public class Solution extends GuessGame &#123; /** * @param n an integer * @return the number you guess **/ public int guessNumber(int n) &#123; // Write your code here int left = 1; int right = n; while (left &lt;= right) &#123; int mid = (right + left) /2; int res = guess(mid); if (res == 0) &#123; return mid; &#125; if(res == -1) &#123; right = mid - 1; &#125;else &#123; left = mid + 1; &#125; &#125; return -1; &#125;&#125; 结果在下列测试用例时发生错误：123456789输入21474836472147483647期望答案2147483647提示Your code ran too much time than we expected. Check your time complexity. Time limit exceeded usually caused by infinite loop if your time complexity is the best. 感觉是发生了溢出，因此将mid的计算方式改成如下形式： 1int mid = left + ((right - left) &gt;&gt; 1); 这句简单的代码做了两个改进： 通过加的形式计算mid，而非直接除以2防止溢出 利用位运算进行除以2的计算更加方便 注意加号和&gt;&gt;的优先级，所以要加个括号 最后顺利AC。这就引发了我对二分查找的思考。 先来看看什么是二分查找： 在计算机科学中，二分搜索（binary search），也称折半搜索（half-interval search）、对数搜索（logarithmic search），是一种在有序数组中查找某一特定元素的搜索算法。搜索过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜索过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组为空，则代表找不到。这种搜索算法每一次比较都使搜索范围缩小一半。 常规套路：12345678910111213141516171819202122public int BinarySearch(int array[], int n, int value)&#123; int left = 0; int right = n - 1; //如果这里是int right = n 的话，那么下面有两处地方需要修改，以保证一一对应： //1、下面循环的条件则是while(left &lt; right) //2、循环内当 array[middle] &gt; value 的时候，right = mid while (left &lt;= right) //循环条件，适时而变 &#123; int middle = left + ((right - left) &gt;&gt; 1); //防止溢出，移位也更高效。同时，每次循环都需要更新。 if (array[middle] &gt; value) right = middle - 1; //right赋值，适时而变 else if (array[middle] &lt; value) left = middle + 1; else return middle; //可能会有读者认为刚开始时就要判断相等，但毕竟数组中不相等的情况更多 //如果每次循环都判断一下是否相等，将耗费时间 &#125; return -1;&#125; 题目变形1. LintCode 14题题目描述： 给定一个排序的整数数组（升序）和一个要查找的整数target，用O(logn)的时间查找到target第一次出现的下标（从0开始），如果target不存在于数组中，返回-1。 样例：在数组 [1, 2, 3, 3, 4, 5, 10] 中二分查找3，返回2。 思路：改变判断条件的临界值 代码：12345678910111213141516171819202122232425262728public class Solution &#123; /** * @param nums: The integer array. * @param target: Target to find. * @return: The first position of target. Position starts from 0. */ public int binarySearch(int[] nums, int target) &#123; // write your code here if (nums.length == 0 || nums == null) return -1; int start = 0; int end = nums.length - 1; int mid = 0; while (start &lt;= end) &#123; mid = start + ((end - start) &gt;&gt; 1); if (nums[mid] &gt;= target) end = mid - 1; else start = mid + 1; &#125; return nums[end+1] == target ? end + 1 : -1; &#125;&#125; 2. LintCode 60题题目描述： 给定一个排序数组和一个目标值，如果在数组中找到目标值则返回索引。如果没有，返回到它将会被按顺序插入的位置。你可以假设在数组中无重复元素。 样例：[1,3,5,6]，5 → 2 [1,3,5,6]，2 → 1 [1,3,5,6]， 7 → 4 [1,3,5,6]，0 → 0 代码：1234567891011121314151617181920212223242526272829303132public class Solution &#123; /** * @param A: an integer sorted array * @param target: an integer to be inserted * @return: An integer */ public int searchInsert(int[] A, int target) &#123; // write your code here if (A.length == 0 || A == null) return 0; int left = 0; int right = A.length - 1; int mid = 0; while (left &lt;= right) &#123; mid = left + ((right - left) &gt;&gt; 1); if (A[mid] &lt; target) &#123; left = mid + 1; &#125; else if (A[mid] &gt;= target) &#123; right = mid - 1; &#125; &#125; //right是数组最后一个元素的情况 if (right == A.length - 1) return right+1; return A[right+1] &gt;= target ? right+1 : right; &#125;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"wanglilin.github.io/categories/数据结构/"}],"tags":[{"name":"高频面试题总结","slug":"高频面试题总结","permalink":"wanglilin.github.io/tags/高频面试题总结/"},{"name":"数据结构","slug":"数据结构","permalink":"wanglilin.github.io/tags/数据结构/"}]},{"title":"高频面试题总结 —— 动规之拼凑面额","slug":"dp-money","date":"2018-03-28T07:47:57.000Z","updated":"2018-03-28T07:51:23.123Z","comments":true,"path":"2018/03/28/dp-money/","link":"","permalink":"wanglilin.github.io/blog/2018/03/28/dp-money/","excerpt":"高频面试题总结 —— 动规之拼凑面额原题地址 题目描述： 给你六种面额1、5、10、20、50、100元的纸币，假设每种币值的数量都足够多，编写程序求组成N元（N为0-10000的非负整数）的不同组合的个数。 样例：输入5输出2","text":"高频面试题总结 —— 动规之拼凑面额原题地址 题目描述： 给你六种面额1、5、10、20、50、100元的纸币，假设每种币值的数量都足够多，编写程序求组成N元（N为0-10000的非负整数）的不同组合的个数。 样例：输入5输出2 思路： 很明显，这是背包问题的变种，需要用到动态规划来解 用dp[i][j]表示当有前i种面额时，组成j元的不同组合的个数 状态转移方程：1dp[i][j] = dp[i-1][j] + dp[i-1][j-coins[i]] tips：每一次都是基于前面一次的结果，即无后效性，为了降低空间复杂度，我们可以做如下改进：1dp[j] = dp[j] + dp[j-coins[i]] 代码：12345678910111213141516171819import java.util.*;public class Main &#123; public static void main(String[] args) &#123; Scanner scan = new Scanner(System.in); int sum = scan.nextInt(); //为int时只能 ac 80% long[] dp = new long[sum+1]; dp[0] = 1L; int[] coins = new int[]&#123;1, 5, 10, 20, 50, 100&#125;; for (int i = 0; i &lt; coins.length; i++) &#123; for (int j = 1; j &lt;= sum; j++) &#123; if (j &gt;= coins[i]) dp[j] = dp[j] + dp[j - coins[i]]; &#125; &#125; System.out.println(dp[sum]); &#125;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"wanglilin.github.io/categories/数据结构/"}],"tags":[{"name":"高频面试题总结","slug":"高频面试题总结","permalink":"wanglilin.github.io/tags/高频面试题总结/"},{"name":"数据结构","slug":"数据结构","permalink":"wanglilin.github.io/tags/数据结构/"}]},{"title":"高频面试题之最长公共系列","slug":"longest-common","date":"2018-03-27T04:32:14.000Z","updated":"2018-03-27T04:36:27.946Z","comments":true,"path":"2018/03/27/longest-common/","link":"","permalink":"wanglilin.github.io/blog/2018/03/27/longest-common/","excerpt":"高频面试题总结 —— 最长公共系列最长公共子串 给出两个字符串，找到最长公共子串，并返回其长度。 样例:给出A=“ABCD”，B=“CBCE”，返回 2 思路：动态规划求解： 当A.charAt(i) == B.charAt(j), 状态转移：dp[i][j] = dp[i-1][j-1] + 1 否则：dp[i][j] = 0 最后求max(dp)","text":"高频面试题总结 —— 最长公共系列最长公共子串 给出两个字符串，找到最长公共子串，并返回其长度。 样例:给出A=“ABCD”，B=“CBCE”，返回 2 思路：动态规划求解： 当A.charAt(i) == B.charAt(j), 状态转移：dp[i][j] = dp[i-1][j-1] + 1 否则：dp[i][j] = 0 最后求max(dp) 代码：123456789101112131415161718192021222324252627282930313233public class Solution &#123; /* * @param A: A string * @param B: A string * @return: the length of the longest common substring. */ public int longestCommonSubstring(String A, String B) &#123; // write your code here int lenA = A.length(); int lenB = B.length(); int[][] dp = new int[lenA + 1][lenB + 1]; for (int i = 1; i &lt;= lenA; i++) &#123; for (int j = 1; j &lt;= lenB; j++) &#123; if (A.charAt(i - 1) == B.charAt(j - 1)) &#123; dp[i][j] = dp[i - 1][j - 1] + 1; &#125; else &#123; dp[i][j] = 0; &#125; &#125; &#125; int max = 0; for (int i = 1; i &lt;= lenA; i++) &#123; for (int j = 1; j &lt;= lenB; j++) &#123; max = Math.max(dp[i][j], max); &#125; &#125; return max; &#125;&#125; 最长公共子序列 给出两个字符串，找到最长公共子序列(LCS)，返回LCS的长度。 样例:给出”ABCD” 和 “EDCA”，这个LCS是 “A” (或 D或C)，返回1给出 “ABCD” 和 “EACB”，这个LCS是”AC”返回 2 12345678910111213141516171819202122232425262728public class Solution &#123; /* * @param A: A string * @param B: A string * @return: The length of longest common subsequence of A and B */ public int longestCommonSubsequence(String A, String B) &#123; // write your code here int lenA = A.length(); int lenB = B.length(); int[][] dp = new int[lenA + 1][lenB + 1]; if (lenA == 0 || lenB == 0 || A == null || B == null) return 0; for (int i = 1; i &lt;= lenA; i++) &#123; for (int j = 1; j &lt;= lenB; j++) &#123; if (A.charAt(i - 1) == B.charAt(j - 1)) dp[i][j] = dp[i-1][j-1] + 1; else dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]); &#125; &#125; return dp[lenA][lenB]; &#125;&#125; 网易面试题 牛牛拿到了一个藏宝图，顺着藏宝图的指示，牛牛发现了一个藏宝盒，藏宝盒上有一个机关，机关每次会显示两个字符串 s 和 t，根据古老的传说，牛牛需要每次都回答 t 是否是 s 的子序列。注意，子序列不要求在原字符串中是连续的，例如串 abc，它的子序列就有 {空串, a, b, c, ab, ac, bc, abc} 8 种。 样例：输入:x.nowcoder.comooo输出:Yes 12345678910111213141516171819202122232425262728293031323334import java.util.*;public class Main &#123; public static void main(String[] args) &#123; Scanner scan = new Scanner(System.in); String s = scan.nextLine(); String t = scan.nextLine(); int lenS = s.length(); int lenT = t.length(); int[][] dp = new int[lenS+1][lenT+1]; if (lenT == 0 || lenS == 0 || s == null || t == null) &#123; System.out.println(\"No\"); return; &#125; for (int i = 1; i &lt;= lenS; i++) &#123; for (int j = 1; j &lt;= lenT; j++) &#123; if (s.charAt(i-1) == t.charAt(j-1)) &#123; dp[i][j] = dp[i-1][j-1] + 1; &#125; else &#123; dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]); &#125; &#125; &#125; if (dp[lenS][lenT] == lenT) &#123; System.out.println(\"Yes\"); &#125; else &#123; System.out.println(\"No\"); &#125; &#125;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"wanglilin.github.io/categories/数据结构/"}],"tags":[{"name":"高频面试题总结","slug":"高频面试题总结","permalink":"wanglilin.github.io/tags/高频面试题总结/"},{"name":"数据结构","slug":"数据结构","permalink":"wanglilin.github.io/tags/数据结构/"}]},{"title":"高频面试题总结之翻转链表","slug":"reverse-linked-list","date":"2018-03-27T02:53:02.000Z","updated":"2018-03-27T03:03:56.917Z","comments":true,"path":"2018/03/27/reverse-linked-list/","link":"","permalink":"wanglilin.github.io/blog/2018/03/27/reverse-linked-list/","excerpt":"高频面试题总结 —— 翻转链表翻转链表是面试中常见的题目，这并不是什么难题，因为要实现翻转，所以一般需要有两个ListNode，通过改变这两个ListNode的前后节点及循环移动这两个节点从而实现链表的翻转。","text":"高频面试题总结 —— 翻转链表翻转链表是面试中常见的题目，这并不是什么难题，因为要实现翻转，所以一般需要有两个ListNode，通过改变这两个ListNode的前后节点及循环移动这两个节点从而实现链表的翻转。 初级翻转链表 给出一个链表1-&gt;2-&gt;3-&gt;null，这个翻转后的链表为3-&gt;2-&gt;1-&gt;null 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/** * Definition for ListNode. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int val) &#123; * this.val = val; * this.next = null; * &#125; * &#125; */public class Solution &#123; /* * @param head: n * @return: The new head of reversed linked list. */ public ListNode reverse(ListNode head) &#123; // write your code here /** * 1. * * */ /**非递归实现 if (head == null || head.next == null) &#123; return head; &#125; ListNode cur = head; ListNode dummy = new ListNode(-1); while (cur != null) &#123; ListNode temp = cur.next; cur.next = dummy.next; dummy.next = cur; cur = temp; &#125; return dummy.next;**/ //递归实现 if (head == null || head.next == null) &#123; return head; &#125; ListNode nextNode = head.next; head.next = null; ListNode reverseResourse = reverse(nextNode); nextNode.next = head; return reverseResourse; &#125;&#125; 翻转部分链表 翻转链表中第m个节点到第n个节点的部分给出链表1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;null， m = 2 和n = 4，返回1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;null 123456789101112131415161718192021222324252627282930313233343536373839/** * Definition for ListNode * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; * val = x; * next = null; * &#125; * &#125; */public class Solution &#123; /** * @param head: ListNode head is the head of the linked list * @param m: An integer * @param n: An integer * @return: The head of the reversed ListNode */ public ListNode reverseBetween(ListNode head, int m, int n) &#123; // write your code here ListNode dummy = new ListNode(-1); dummy.next = head; ListNode pre = dummy; ListNode cur = head; for (int i = 1; i &lt; m; i++) &#123; pre = pre.next; cur = cur.next; &#125; //与翻转链表的不同是要保持第一个节点不变 for (int i = 0; i &lt; n - m; i++) &#123; ListNode temp = cur.next; cur.next = temp.next; temp.next = pre.next; pre.next = temp; &#125; return dummy.next; &#125;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"wanglilin.github.io/categories/数据结构/"}],"tags":[{"name":"高频面试题总结","slug":"高频面试题总结","permalink":"wanglilin.github.io/tags/高频面试题总结/"},{"name":"数据结构","slug":"数据结构","permalink":"wanglilin.github.io/tags/数据结构/"}]},{"title":"天池比赛小结","slug":"ksum","date":"2018-03-05T03:45:50.000Z","updated":"2018-03-05T03:58:40.170Z","comments":true,"path":"2018/03/05/ksum/","link":"","permalink":"wanglilin.github.io/blog/2018/03/05/ksum/","excerpt":"天池比赛小结1巧妙利用回溯法解决路径提交所引发的血案0 引言前一阵子参加了天池比赛气象数据领航无人飞行器线路优化大赛，凭借着初赛一步步的稳扎稳打以及最后时刻的一波套磁 + 人品爆发，以第三名的成绩进入了决赛。但在决赛阶段，我们所遇到的最大问题并不是此次赛题中的两个重点：气象数据回归或路径规划算法，令我们差点止步前 10 的是提交路径之后，由于不同路径之间的各种组合导致的无法推知到底是哪些路径成功抵达。后来我们用了一些巧妙的解法在某种程度上解决了这个问题（并没有完全解决，下文会细讲），因此，这也是此篇博客诞生的原因，想要记录下解决这一个问题的思路。","text":"天池比赛小结1巧妙利用回溯法解决路径提交所引发的血案0 引言前一阵子参加了天池比赛气象数据领航无人飞行器线路优化大赛，凭借着初赛一步步的稳扎稳打以及最后时刻的一波套磁 + 人品爆发，以第三名的成绩进入了决赛。但在决赛阶段，我们所遇到的最大问题并不是此次赛题中的两个重点：气象数据回归或路径规划算法，令我们差点止步前 10 的是提交路径之后，由于不同路径之间的各种组合导致的无法推知到底是哪些路径成功抵达。后来我们用了一些巧妙的解法在某种程度上解决了这个问题（并没有完全解决，下文会细讲），因此，这也是此篇博客诞生的原因，想要记录下解决这一个问题的思路。 1 问题该比赛要求我们规划 5 天之中的 10 条飞行路线，即总共要规划 5*10 = 50 条，并要求时间最短，安全性最高。那么，这就会引发如下问题： 某几条路径都是最短路径，所以其耗时是一样的。譬如：从起始点飞往城市 2 所耗费的最短时间是 200 min，那么如果我们所提交的路径之中5天的飞往城市2的时间都是最短时间，那么我们则无法推知到底是哪几条过了。 不同路径之间的组合导致同一个分数有多种方案。譬如：飞往城市 1 用了 150 min， 飞往城市 2 用了250 min , 飞往城市 3 用了 100 min，飞往城市 4 用了 300 min，那么，如果最后的成绩显示是 400 min，那么我们将无法得知是路径1和2到达，还是路径3和4到达。 好，那我们其实在决赛前有想到会出现这种情况，不过我们还是too young，忽略了问题的复杂性，我们一开始的想法是只要对每条路径进行微调（在时间允许范围内+2/+4/+8啥的）从而区分耗时相同的路径即可，然而…这种解决方式会加剧问题 2 （譬如路径A+B = C+D，微调过后仍会出现 （A+2）+ （B+6）= (C+4) + (C+4) 等情况的出现），即会出现更多的不同路径组合而总消耗时间相同的情况。 所以还要花很多时间在微调数的设置上，并没有从根本上解决问题。 2 伪解决方案为什么说其是伪解决方案呢，因为该解决方案并没有完全解决我们的问题，但是可以某种程度上解决我们的问题。话不多说，我们最终采用的方案如下： Step 1 : 每次提交只提交少量的线路，比如，一次提交只涉及5天中某一天的10条路线 Step 2：通过基于dfs的改进k数和算法检验这些线路是否存在不同组合而消耗相同时间的问题 Step 3：若有，则继续微调每条线路的耗时，若没有，则可以提交 3 K数和其实这个问题究其本质，就是K数和问题。K数和问题定义： Given n unique integers, number k (1&lt;=k&lt;=n) and target.Find all possible k integers where their sum is target. 样例： 给出[1,2,3,4]，k=2， target=5，返回 [[1,4],[2,3]] 解题思路利用递归与回溯来解 代码： Java 1234567891011121314151617181920212223242526272829public class Solution &#123; /** * @param A: an integer array. * @param k: a positive integer (k &lt;= length(A)) * @param target: a integer * @return a list of lists of integer */ public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; kSumII(int A[], int k, int target) &#123; // write your code here ArrayList&lt;ArrayList&lt;Integer&gt;&gt; result = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;(); ArrayList&lt;Integer&gt; path = new ArrayList&lt;Integer&gt;(); helper(result, path, A, k, target, 0); return result; &#125; public void helper(ArrayList&lt;ArrayList&lt;Integer&gt;&gt; result,ArrayList&lt;Integer&gt; path,int [] A,int k ,int remain,int index)&#123; if(path.size() == k)&#123; if(remain ==0) result.add(new ArrayList&lt;Integer&gt;(path)); else return; &#125; for(int i = index; i&lt; A.length; i++)&#123; path.add(A[i]); helper(result, path, A, k, remain - A[i], i+1); path.remove(path.size() - 1); &#125; &#125;&#125; Python 123456789101112131415161718192021222324class Solution: \"\"\" @param A: An integer array. @param k: A positive integer (k &lt;= length(A)) @param target: Integer @return a list of lists of integer \"\"\" def kSumII(self, A, k, target): # write your code here path = [] result = [] self.helper(result,path,A,k,target,0) return result def helper(self,result , path ,A ,k,target,index): if len(path) == k: if target==0: result.append(path[:]) else: for i in range(index,len(A)): path.append(A[i]) self.helper(result,path,A,k,target - A[i] ,i + 1) path.pop() 4 K数和&amp;字典要将K数和与本问题结合，还需要做一点小小的处理。即我们希望最后是直接输出路径的组合，而非路径耗时的组合，因此，最终我们的代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243class GetSuccessPath(): def helper(self, results_len, path, len_list, target, index): \"\"\" DFS+回溯法 :param results_len: 成功到达的每条路径所耗时长组成的list :param path: 成功到达的路径组合 :param len_list: 提交结果中每条路径所耗时长组成的list :param target: 总共耗时 :param index: 当前路径的index :return: \"\"\" if target == 0: results_len.append(path[:]) else: for i in range(index, len(len_list)): path.append(len_list[i]) self.helper(results_len, path, len_list, target - len_list[i], i + 1) path.pop() def get_path(self, dict_path_len, target): \"\"\" 用于快速求得提交路径中成功到达的路径 :param dict_path_len: 将提交结果用字典形式表示出来，&#123;key: path 形如\"day6path5\", value: len 路径所耗时长&#125; :param target: 提交之后得到的总时间 :return: 成功到达的路径，每个list代表一种可能，如[['day6path5', 'day6path6'], ['day6path7']] \"\"\" len_list = [value for key, value in dict_path_len.items()] # 求提交结果中每条路径所耗时长组成的list # key value对调，为后续依靠路径长度得到成功到达的路径做准备 dict_len_path = &#123;value: key for key, value in dict_path_len.items()&#125; path = [] results_len = [] self.helper(results_len, path, len_list, target, 0) # 根据成功到达路径长度的组合得到成功到达的各个路径名 results_path = [] for result in results_len: result_path = [dict_len_path.get(length) for length in result] results_path.append(result_path) return results_pathif __name__ == \"__main__\": dict_path_len = &#123;\"day6path5\": 1, \"day6path6\": 15, \"day6path7\": 3, \"day6path8\": 4, \"day6path9\": 5&#125; g = GetSuccessPath() print(g.get_path(dict_path_len, 16)) 以上代码未考虑到线上评分机制：目标函数值 = 2460飞行器坠毁数 + 顺利到达的飞行器总飞行时长（分钟） 考虑以上机制后，我们的代码改进为：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#!/usr/bin/env python# -*- coding: utf-8 -*-# @Time : 2018/2/2 16:50# @Author : WangliLin# @Site : # @File : get_success_path.py# @Software: PyCharmclass GetSuccessPath(): def helper(self, results_len, path, len_list, target, index): \"\"\" DFS+回溯法 :param results_len: 成功到达的每条路径所耗时长组成的list :param path: 成功到达的路径组合 :param len_list: 提交结果中每条路径所耗时长组成的list :param target: 总共耗时 :param index: 当前路径的index :return: \"\"\" if target == 0: results_len.append(path[:]) else: for i in range(index, len(len_list)): path.append(len_list[i]) self.helper(results_len, path, len_list, target - len_list[i], i + 1) path.pop() def get_path(self, dict_path_len, online_score): \"\"\" 用于快速求得提交路径中成功到达的路径 :param dict_path_len: 将提交结果用字典形式表示出来，&#123;key: path 形如\"day6path5\", value: len 路径所耗时长&#125; :param online_score: 线上成绩 :return: 成功到达的路径，每个list代表一种可能，如[['day6path5', 'day6path6'], ['day6path7']] \"\"\" target = 24*60*50 - online_score len_list = [24*60-value for key, value in dict_path_len.items()] # key value对调，为后续依靠路径长度得到成功到达的路径做准备 dict_len_path = &#123;24*60-value: key for key, value in dict_path_len.items()&#125; path = [] results_len = [] self.helper(results_len, path, len_list, target, 0) # 根据成功到达路径长度的组合得到成功到达的各个路径名 results_path = [] for result in results_len: result_path = [dict_len_path.get(length) for length in result] results_path.append(result_path) return results_pathif __name__ == \"__main__\": \"\"\" 24*60*总条数 - 线上总成绩 = 24*60*成功到达的路径 - Sum(成功到达的路径耗时) \"\"\" dict_path_len = &#123; \"day10path2\": 202, \"day10path9\": 130, \"day6path10\": 222, \"day6path2\" : 200, \"day6path5\" : 904, \"day6path9\" : 128, \"day7path2\" : 204, \"day7path9\" : 132, \"day8path2\" : 206, \"day8path5\" : 460, \"day8path7\" : 660, \"day8path8\" : 706, \"day9path2\" : 208, \"day9path9\" : 136, \"day8path6\" : 550 &#125; online_score = 56338 g = GetSuccessPath() print(g.get_path(dict_path_len, online_score)) 全部思路大致如上。接下来即可实现两个功能： 线下模拟评测不同耗时下的路线组合数，从而对路线进行微调 根据线上成绩，快速得到成功到达的路径组合","categories":[{"name":"天池大数据竞赛","slug":"天池大数据竞赛","permalink":"wanglilin.github.io/categories/天池大数据竞赛/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"wanglilin.github.io/tags/数据结构/"},{"name":"天池","slug":"天池","permalink":"wanglilin.github.io/tags/天池/"}]},{"title":"UnionFind","slug":"UnionFind","date":"2017-12-27T09:13:27.000Z","updated":"2017-12-27T09:22:43.019Z","comments":true,"path":"2017/12/27/UnionFind/","link":"","permalink":"wanglilin.github.io/blog/2017/12/27/UnionFind/","excerpt":"并查集写该篇博客的初衷是由于在做天池大数据比赛中用到了并查集的相关概念，因此，想要巩固下这个知识点。 在计算机科学中，并查集是一种树型的数据结构，用于处理一些不相交集合（Disjoint Sets）的合并及查询问题。有一个联合-查找算法（union-find algorithm）定义了两个用于此数据结构的操作： Find：确定元素属于哪一个子集。它可以被用来确定两个元素是否属于同一子集。 Union：将两个子集合并成同一个集合。 由于支持这两种操作，一个不相交集也常被称为联合-查找数据结构（union-find data structure）或合并-查找集合（merge-find set）。","text":"并查集写该篇博客的初衷是由于在做天池大数据比赛中用到了并查集的相关概念，因此，想要巩固下这个知识点。 在计算机科学中，并查集是一种树型的数据结构，用于处理一些不相交集合（Disjoint Sets）的合并及查询问题。有一个联合-查找算法（union-find algorithm）定义了两个用于此数据结构的操作： Find：确定元素属于哪一个子集。它可以被用来确定两个元素是否属于同一子集。 Union：将两个子集合并成同一个集合。 由于支持这两种操作，一个不相交集也常被称为联合-查找数据结构（union-find data structure）或合并-查找集合（merge-find set）。 并查集用途 维护无向图的连通性，支持判断两个点是否在同一个连通块内，和判断增加一条边是否会产生环 用在求解最小生成树的Kruskal算法里 为了更加准确的定义这些方法，需要首先定义集合。一种常用的策略是为每个集合选定一个固定的元素，称为代表，以表示整个集合。接着，Find(x)返回x所属集合的代表，而Union使用两个集合的代表作为参数。 代表元用集合中的某个元素来代表这个集合，该元素称为集合的代表元。 一个集合内的所有元素组织成以代表元为根的树形结构 对于每一个元素，parent[x]指向在树形结构上的父亲节点。如果x是根节点，则令parent[x] = x 对于查找操作，假设需要确定x所在的集合，也就是确定集合的代表元，可以沿着parent[x]不断在树形结构中向上移动，直到到达根节点。判断两个元素是否属于同一个集合，只需要看他们的代表元是否相同即可 并查集森林并查集森林是一种将每一个集合以树表示的数据结构，其中每一个节点保存着它的父节点的引用，在并查集森林中，每个集合的代表即是集合的根节点。“查找”根据其父节点的引用向根行进直到树根。“联合”将两棵树合并到一起，这通过将一棵树的根连接到另一棵树的根。实现该操作的代码如下： 12345678910111213def MakeSet(x): x.parent = xdef Find(x): if x.parent = x: return x else: return Find(x.parent)def Union(x, y): xRoot = Find(x) yRoot = Find(y) xRoot.parent = yRoot 这是并查集森林的最基础的表示方法，这个方法并不好，因为创建的树可能会严重不平衡；可以用两种方法优化： 按秩合并即总是将更小的树连接至更大的树上。因为影响运行时间的是树的深度，更小的树添加到更深的树的根上将不会增加秩除非他们的秩相同。在这个算法中，术语“秩”替代了“深度”，因为同时应用了路径压缩时秩将不会与高度相同，单元素的树的秩定义为0，当两棵秩同为r的树联合时，他们的秩为r+1。只使用这个方法将使最坏的运行时间提高至每个MakeSet、Union或Find操作O(logn)。 路径压缩是一种在执行“查找”时扁平化树结构的方法。关键在于在路径上的每个节点都可以直接连接到根上；他们都有同样的表示方法。为了达到这样的效果，Find递归地经过树，改变每一个节点的引用到根节点，得到的树将更加扁平，为以后直接或者间接引用节点的操作加速。 这两种方法的优势互补，同时使用二者的程序每个操作的平均时间仅为O(a(n))。因为a(n)在n十分巨大时还是小于5，因此，平均运行时间是一个极小的常数。 并查集应用1. LintCode 178 判断图是否为树（Java实现） 给出 n 个节点，标号分别从 0 到 n - 1 并且给出一个 无向 边的列表 (给出每条边的两个顶点), 写一个函数去判断这张｀无向｀图是否是一棵树 注意事项你可以假设我们不会给出重复的边在边的列表当中. 无向边 [0, 1] 和 [1, 0] 是同一条边， 因此他们不会同时出现在我们给你的边的列表当中。 样例给出n = 5 并且 edges = [[0, 1], [0, 2], [0, 3], [1, 4]], 返回 true给出n = 5 并且 edges = [[0, 1], [1, 2], [2, 3], [1, 3], [1, 4]], 返回 false. 代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class Solution &#123; /* * @param n: An integer * @param edges: a list of undirected edges * @return: true if it's a valid tree, or false */ class UnionFind &#123; HashMap&lt;Integer, Integer&gt; father = new HashMap&lt;Integer, Integer&gt;(); UnionFind(int n) &#123; for (int i=0; i &lt; n; i++) &#123; father.put(i, i); &#125; &#125; int compressed_find(int x) &#123; int parent = father.get(x); while(parent != father.get(parent)) &#123; parent = father.get(parent); &#125; int temp = -1; int fa = father.get(x); while (fa != father.get(fa)) &#123; temp = father.get(fa); father.put(fa, parent); fa = temp; &#125; return parent; &#125; void union(int x, int y) &#123; int fa_x = compressed_find(x); int fa_y = compressed_find(y); if (fa_x != fa_y) father.put(fa_x, fa_y); &#125; &#125; public boolean validTree(int n, int[][] edges) &#123; // write your code here if (n - 1 != edges.length) &#123; return false; &#125; UnionFind uf = new UnionFind(n); for (int i = 0; i &lt; edges.length; i++) &#123; if (uf.compressed_find(edges[i][0]) == uf.compressed_find(edges[i][1])) &#123; return false; &#125; uf.union(edges[i][0], edges[i][1]); &#125; return true; &#125;&#125; 2. 天池比赛中用于图之间任意两个节点是否有连接（Python实现）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101class UnionFind(object): def __init__(self, groups): self.groups = groups # 外部传入的相连接的点 self.items = [] # 所有的元素 for group in groups: self.items += list(group) self.items = set(self.items) self.parent = &#123;&#125; # 父亲节点 for item in self.items: self.parent[item] = item self.create_tree() def findroot(self, r): \"\"\" 查找根节点 \"\"\" if r == self.parent[r]: return r else: # 路径压缩 self.parent[r] = self.findroot(self.parent[r]) return self.parent[r] def union(self, p, q): \"\"\" 合并p和q两个节点 \"\"\" p_root = self.findroot(p) q_root = self.findroot(q) if p_root == q_root: return # 将父节点指向另一个节点 self.parent[p_root] = q_root return def create_tree(self): \"\"\" 根据groups来构造树结构 \"\"\" for group in self.groups: if len(group) &lt; 2: continue for i in range(len(group) - 1): if self.findroot(group[i]) != self.findroot(group[i + 1]): self.union(group[i], group[i + 1]) def is_connected(self, p, q): \"\"\" 判断两个节点是否连接 \"\"\" if p not in self.items or q not in self.items: return False return self.findroot(p) == self.findroot(q) def add_groups(self, groups): \"\"\" 增加连接 \"\"\" self.groups = self.groups + groups for group in groups: for item in group: if item in self.items: continue self.items = list(self.items) self.items.append(item) self.parent[item] = item self.items = set(self.items) self.create_tree() def print_trees(self): \"\"\" 打印出相连接的树结构 \"\"\" rs = &#123;&#125; for item in self.items: root = self.findroot(item) rs.setdefault(root, []) rs[root].append(item) for key in rs: print (rs[key]) print ('*************************') def get_items(self): \"\"\" 获取所有的元素 \"\"\" return self.itemsif __name__ == '__main__': # 测试功能 groups = [((1,1), (1,2)), ((3,4), (3,3)), ((1,1), (0,1))] u = UnionFind(groups) u.print_trees() u.add_groups([((3,4), (3,5))]) print ('after adding') u.print_trees() print (u.is_connected((1,1), (3,4))) print(u.is_connected((1, 2), (0, 1)))","categories":[{"name":"数据结构","slug":"数据结构","permalink":"wanglilin.github.io/categories/数据结构/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"wanglilin.github.io/tags/数据结构/"}]},{"title":"mooc-ii","slug":"mooc-ii","date":"2017-09-18T15:27:38.000Z","updated":"2017-09-25T07:21:50.674Z","comments":true,"path":"2017/09/18/mooc-ii/","link":"","permalink":"wanglilin.github.io/blog/2017/09/18/mooc-ii/","excerpt":"mooc 数据结构第二节作业一元多项式的乘法与加法运算设计函数分别求两个一元多项式的乘积与和。 输入格式:输入分2行，每行分别先给出多项式非零项的个数，再以指数递降方式输入一个多项式非零项系数和指数（绝对值均为不超过1000的整数）。数字间以空格分隔。 输出格式:输出分2行，分别以指数递降方式输出乘积多项式以及和多项式非零项的系数和指数。数字间以空格分隔，但结尾不能有多余空格。零多项式应输出0 0。 输入样例:124 3 4 -5 2 6 1 -2 03 5 20 -7 4 3 1 输出样例1215 24 -25 22 30 21 -10 20 -21 8 35 6 -33 5 14 4 -15 3 18 2 -6 15 20 -4 4 -5 2 9 1 -2 0","text":"mooc 数据结构第二节作业一元多项式的乘法与加法运算设计函数分别求两个一元多项式的乘积与和。 输入格式:输入分2行，每行分别先给出多项式非零项的个数，再以指数递降方式输入一个多项式非零项系数和指数（绝对值均为不超过1000的整数）。数字间以空格分隔。 输出格式:输出分2行，分别以指数递降方式输出乘积多项式以及和多项式非零项的系数和指数。数字间以空格分隔，但结尾不能有多余空格。零多项式应输出0 0。 输入样例:124 3 4 -5 2 6 1 -2 03 5 20 -7 4 3 1 输出样例1215 24 -25 22 30 21 -10 20 -21 8 35 6 -33 5 14 4 -15 3 18 2 -6 15 20 -4 4 -5 2 9 1 -2 0 代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184import java.util.Scanner;class Node &#123; Node next; int value; int exp; public Node(int value, int exp) &#123; this.value = value; this.exp = exp; &#125; public void add(int value, int exp) &#123; if(this.next == null) &#123; this.next = new Node(value, exp); &#125; else &#123; this.next.add(value, exp); &#125; &#125;&#125;public class Main &#123; public static Node funAdd(Node p1, Node p2) &#123; int value = 0, exp = 0; Node p3 = null; while(p1 != null &amp;&amp; p2!= null) &#123; if(p1.exp &gt; p2.exp) &#123; if (p3 == null) &#123; p3 = new Node(p1.value, p1.exp); &#125; else &#123; p3.add(p1.value, p1.exp); &#125; p1 = p1.next; &#125; else if (p1.exp &lt; p2.exp) &#123; if(p3 == null) &#123; p3 = new Node(p2.value, p2.exp); &#125; else &#123; p3.add(p2.value, p2.exp); &#125; p2 = p2.next; &#125; else if (p1.exp == p2.exp) &#123; if (p1.value + p2.value == 0) &#123; value = 0; exp = 0; &#125; else &#123; value = p1.value + p2.value; exp = p1.exp; &#125; if (p3 == null) &#123; p3 = new Node(value, exp); &#125; else &#123; p3.add(value, exp); &#125; p1 = p1.next; p2 = p2.next; &#125; &#125; while (p1 != null) &#123; if (p3 == null) &#123; p3 = new Node(p1.value, p1.exp); &#125; else &#123; p3.add(p1.value, p1.exp); &#125; p1 = p1.next; &#125; while (p2 != null) &#123; if (p3 == null) &#123; p3 = new Node(p2.value, p2.exp); &#125; else &#123; p3.add(p2.value, p2.exp); &#125; p2 = p2.next; &#125; return p3; &#125; public static void print(Node p) &#123; if (p.value == 0) &#123; System.out.println(\"0 0\"); &#125; else &#123; while (p != null) &#123; if (p.value != 0) &#123; System.out.print(p.value + \" \" + p.exp); &#125; p = p.next; if (p != null) &#123; if (p.value != 0) &#123; System.out.print(\" \"); &#125; &#125; &#125; System.out.println(); &#125; &#125; public static Node funMulti(Node p1, Node p2) &#123; int value = 0, exp = 0; Node temp = p2; Node p = null, p3 = null; int i = 1; while (p1 != null) &#123; while (p2 != null) &#123; if (p1.value * p2.value == 0) &#123; value = 0; exp = 0; &#125; else &#123; value = p1.value*p2.value; exp = p1.exp + p2.exp; &#125; if (i == 1) &#123; if (p == null) &#123; p = new Node(value, exp); &#125; else &#123; p.add(value, exp); &#125; &#125; else &#123; if (p3 == null) &#123; p3 = new Node(value, exp); &#125; else &#123; p3.add(value, exp); &#125; &#125; p2 = p2.next; &#125; i = 2; p = funAdd(p, p3); p1 = p1.next; p2 = temp; p3 = null; &#125; return p; &#125; public static Node scanIn(Scanner scanner,int T, Node p) &#123; while(T-- != 0) &#123; int value = scanner.nextInt(); int exp = scanner.nextInt(); if (p == null) &#123; p = new Node(value, exp); &#125; else &#123; p.add(value,exp); &#125; &#125; return p; &#125; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); Node p1 = null, p2 = null; int T1 = scanner.nextInt(); int temp1 = T1; p1 = scanIn(scanner, T1, p1); int T2 = scanner.nextInt(); int temp2 = T2; if (T2 == 0) &#123; p2 = new Node(0, 0); &#125; p2 = scanIn(scanner, T2, p2); if (temp1 != 0 &amp;&amp; temp2 != 0) &#123; Node p = funMulti(p1, p2); print(p); &#125; else &#123; System.out.println(\"0 0\"); &#125; Node p = funAdd(p1, p2); print(p); &#125;&#125; Reversing Linked ListGiven a constant K and a singly linked list L, you are supposed to reverse the links of every K elements on L. For example, given L being 1→2→3→4→5→6, if K=3, then you must output 3→2→1→6→5→4; if K=4, you must output 4→3→2→1→5→6. Input Specification:Each input file contains one test case. For each case, the first line contains the address of the first node, a positive N (≤10​5​​ ) which is the total number of nodes, and a positive K (≤N) which is the length of the sublist to be reversed. The address of a node is a 5-digit nonnegative integer, and NULL is represented by -1. Then N lines follow, each describes a node in the format:1Address Data Next where Address is the position of the node, Data is an integer, and Next is the position of the next node. Output Specification:For each case, output the resulting ordered linked list. Each node occupies a line, and is printed in the same format as in the input. Sample Input:123456700100 6 400000 4 9999900100 1 1230968237 6 -133218 3 0000099999 5 6823712309 2 33218 Sample Output:12345600000 4 3321833218 3 1230912309 2 0010000100 1 9999999999 5 6823768237 6 -1 代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;public class Main &#123; public static void main(String[] args) throws IOException &#123; int first, n, k; BufferedReader buf = new BufferedReader(new InputStreamReader(System.in)); String[] str = buf.readLine().split(\" \"); first = Integer.parseInt(str[0]); n = Integer.parseInt(str[1]); k = Integer.parseInt(str[2]); int temp; int[] data = new int[100005]; int[] next = new int[100005]; for (int i = 0; i &lt; n; i++) &#123; str = buf.readLine().split(\" \"); temp = Integer.parseInt(str[0]); data[temp] = Integer.parseInt(str[1]); next[temp] = Integer.parseInt(str[2]); &#125; buf.close(); int[] list = new int[n]; int sum = 0; while (first != -1) &#123; list[sum++] = first; first = next[first]; &#125; int[] result = new int[100005]; for (int i = 0; i &lt; sum; i++) &#123; result[i] = list[i]; &#125; for (int i = 0; i &lt; k; i++) &#123; result[i] = list[k - 1 - i]; &#125; for (int i = 0; i &lt; sum - 1; i++) &#123; System.out.printf(\"%05d %d %05d\\n\", result[i], data[result[i]], result[i + 1]); &#125; System.out.printf(\"%05d %d -1\\n\", result[sum-1] , data[result[sum-1]]); &#125;&#125; 但是运行时间方面不如C++，C++版本如下：123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;using namespace std;int main() &#123; int first, k, n; cin &gt;&gt; first &gt;&gt; n &gt;&gt; k; // 把地址为temp的数的数值存入data[temp]中，把temp的下一个结点的地址存入next[temp]中。 int temp; int data[100005]; int next[100005]; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; temp; cin &gt;&gt; data[temp]; cin &gt;&gt; next[temp]; &#125; int list[100005]; int sum = 0;//不一定所有的输入的结点都是有用的，加个计数器 while (first != -1) &#123; list[sum++] = first; first = next[first]; &#125; int result[100005]; for (int i = 0; i &lt; sum; i++) &#123; result[i] = list[i]; &#125; for (int i = 0; i &lt; (sum - sum % k); i++) &#123; result[i] = list[i / k * k + k - 1 - i % k]; &#125; for (int i = 0; i &lt; sum - 1; i++) printf(\"%05d %d %05d\\n\", result[i], data[result[i]], result[i + 1]); printf(\"%05d %d -1\", result[sum - 1], data[result[sum - 1]]); return 0;&#125; Pop SequenceGiven a stack which can keep M numbers at most. Push N numbers in the order of 1, 2, 3, …, N and pop randomly. You are supposed to tell if a given sequence of numbers is a possible pop sequence of the stack. For example, if M is 5 and N is 7, we can obtain 1, 2, 3, 4, 5, 6, 7 from the stack, but not 3, 2, 1, 7, 5, 6, 4. Input Specification:Each input file contains one test case. For each case, the first line contains 3 numbers (all no more than 1000): M (the maximum capacity of the stack), N (the length of push sequence), and K (the number of pop sequences to be checked). Then K lines follow, each contains a pop sequence of N numbers. All the numbers in a line are separated by a space. Output Specification:For each pop sequence, print in one line “YES” if it is indeed a possible pop sequence of the stack, or “NO” if not. Sample Input:1234565 7 51 2 3 4 5 6 73 2 1 7 5 6 47 6 5 4 3 2 15 6 4 3 7 2 11 7 6 5 4 3 2 Sample Output:12345YESNONOYESNO 思路：按照要求进行模拟。先把输入的序列接收进数组v。然后按顺序1~n把数字进栈，每进入一个数字，判断有没有超过最大范围，超过了就break。如果没超过，设current = 1，从数组的第一个数字开始，看看是否与栈顶元素相等，while相等就一直弹出栈，不相等就继续按顺序把数字压入栈~最后根据变量flag的bool值输出yes或者no 代码如下：12345678910111213141516171819202122232425262728293031323334353637383940import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.Stack;public class Main &#123; public static void main(String[] args) throws IOException &#123; BufferedReader buf = new BufferedReader(new InputStreamReader(System.in)); String[] row = buf.readLine().split(\" \"); int m = Integer.parseInt(row[0]); int n = Integer.parseInt(row[1]); int k = Integer.parseInt(row[2]); for (int i = 0; i &lt; k; i++) &#123; boolean flag = false; Stack&lt;Integer&gt; st = new Stack&lt;Integer&gt;(); int[] v = new int[n+1]; row = buf.readLine().split(\" \"); for (int j = 1; j &lt;= n; j++) &#123; v[j] = Integer.parseInt(row[j - 1]); &#125; int current = 1; for (int j = 1; j &lt;= n; j++) &#123; st.push(j); if (st.size() &gt; m) break; while (!st.isEmpty() &amp;&amp; st.peek() == v[current]) &#123; st.pop(); current++; &#125; &#125; if (current == n+1) flag = true; if (flag) System.out.println(\"YES\"); else System.out.println(\"NO\"); &#125; &#125;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"wanglilin.github.io/categories/数据结构/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"wanglilin.github.io/tags/数据结构/"},{"name":"mooc","slug":"mooc","permalink":"wanglilin.github.io/tags/mooc/"}]},{"title":"Java源码阅读-HashMap","slug":"java-hashmap-i","date":"2017-09-16T04:19:25.000Z","updated":"2017-09-16T04:37:49.624Z","comments":true,"path":"2017/09/16/java-hashmap-i/","link":"","permalink":"wanglilin.github.io/blog/2017/09/16/java-hashmap-i/","excerpt":"HashMap源码阅读（上）1.HashMap数据结构简介HashMap就是数据结构中的散列表，是以key、value的形式进行存储数据的。数组具有查找定位快，但是插入操作性能差的特点；链表具有查找慢插入快的特点，而HashMap可以说是这两种方式的一种折中。HashMap采用数组与链表相结合的方式实现，其数据结构示意图如下图所示：","text":"HashMap源码阅读（上）1.HashMap数据结构简介HashMap就是数据结构中的散列表，是以key、value的形式进行存储数据的。数组具有查找定位快，但是插入操作性能差的特点；链表具有查找慢插入快的特点，而HashMap可以说是这两种方式的一种折中。HashMap采用数组与链表相结合的方式实现，其数据结构示意图如下图所示： HashMap的特点 可以存储null值（HashMap可以接受为null的键或值） 非线程安全 存储查找速度快 HashMap的性能影响HashMap性能的因素： 哈希函数均匀：HashMap是通过hash函数来定位数组下标，进而确定对象存储位置的，最坏的情况是通过hash函数计算出的下标都为相同，那么HashMap就退化成链表了，最好的情况是都不相同那么就能达到O(1)的效率，所以hash计算出来冲突产生越多，那么查找效率就越低。冲突越少查找效率越高。 处理冲突的方法：既要有较高的查找性能，又要有较高的插入性能，那么冲突就无法避免，解决冲突的方式也决定了其性能的优劣。 2.HashMap具体实现从key到数组的下标 首先根据key调用hashCode()方法生成hashCode 调用hash()方法根据生成的hashCode生成hash值 利用hash值与数组table的length - 1求余得到数组下标（为了使得到的数组在数组区间内） hash() 1234static final int hash(Object key) &#123; int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16); &#125; 这段代码叫扰动函数，大家都知道上面代码中的key.hashCode()函数调用的是key键值类型自带的哈希函数，返回int型散列值。理论上散列值是一个int型，如果直接拿散列值作为下标访问HashMap主数组的话，考虑到带符号的int表值范围前后加起来大概40亿的映射空间，只要哈希函数映射得比较均匀松散，一般应用是很难出现碰撞的。但问题是一个40亿长度的数组，内存是放不下的。HashMap扩容之前的数组初始大小才16，所以这个散列值是不能直接拿来用的。用之前还要先做对数组的长度取模运算，得到的余数才能用来访问数组下标。源码中模运算是在类似indexFor()函数里这样完成的：12345bucketIndex = indexFor(hash, table.length);static int indexFor(int h, int length) &#123; return h &amp; (length-1);&#125; 这正好解释了为什么HashMap的数组长度要取2的整次幂，因为这样（数组长度 - 1）正好相当于一个“低位掩码”，“与”操作的结果就是散列值得高位全部归零，只保留低位值，用来做下标访问。以初始长度为16示例，16 - 1 = 15，2进制表示就是00000000 00000000 00001111。和某散列值做“与”操作如下，结果就是截取了最低的四位值。1234 10100101 11000100 00100101&amp; 00000000 00000000 00001111---------------------------------- 00000000 00000000 00000101 //高位全部归零，只保留末四位 但这时候问题就来了，就算散列值分布再分散，要是只取最后几位的话，碰撞也会很严重，更要命的是如果散列本身做得不好，分布上成等差数列的漏洞，恰好使最后几个低位呈现规律性重复，就会造成很严重的后果。这时候“扰动函数”的价值就体现出来了，如下图：右位移16位，正好是32bit的一半，自己的高半区和低半区做异或，就是为了混合原始哈希码的高位和低位，以此来加大低位的随机性。而且混合后的低位参杂了高位的部分特征，这样高位的信息也被变相保留下来。参考：JDK 源码中 HashMap 的 hash 方法原理是什么？ 数组大小这里涉及到一个非常有趣且niubi的函数tableSizeFor()，其源码如下： 12345678910111213static final int MAXIMUM_CAPASITY = 1 &lt;&lt; 30;/** * Returns a power of two size for the given target capacity. */static final int tableSizeFor(int cap) &#123; int n = cap - 1; n |= n &gt;&gt;&gt; 1; n |= n &gt;&gt;&gt; 2; n |= n &gt;&gt;&gt; 4; n |= n &gt;&gt;&gt; 8; n |= n &gt;&gt;&gt; 16; return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;&#125; 这个方法被调用的地方： 12345public HashMap(int initialCapacity, float loadFactor) &#123; /**省略此处代码**/ this.loadFactor = loadFactor; this.threshold = tableSizeFor(initialCapacity); &#125; 上面的方法就是数组大小生成的方法，永远生成的是一个2的幂的数，也就是说例如输入15，返回的结果就是16。为什么这个方法总能在给定一个值之后返回一个大于它同时最接近它或者等于它的2次幂呢？首先看下下面这段二进制数据： 123452的0次方2进制 0000 0001 十进制 12的1次方2进制 0000 0010 十进制 22的2次方2进制 0000 0100 十进制 42的3次方2进制 0000 1000 十进制 82的4次方2进制 0001 0000 十进制 16 我们发现临近的两个2的幂的高位是相邻的。 123456789101112131415161718192021例如7要取到8 所以将0000 0111无符号右移0000 0111 &gt;&gt;&gt;1 等于 0000 0011进行与操作 （只要存在1那么是1）0000 0111 | 0000 0011 等于 0000 0111n + 1（源码三目运算符）0000 0111 + 0000 0001=0000 1000给定数字为4最后通过右移变成80000 0100无符号右移10000 0100 &gt;&gt;&gt;1 等于 0000 0010进行与操作 （只要存在1那么是1）0000 0100 | 0000 0010 等于 0000 0110接着因为已经有2位达到变成1的目的，所以接着就是移动2位0000 0110 &gt;&gt;&gt; 0000 0011进行与操作 （只要存在1那么是1）0000 0110 | 0000 0011 等于 0000 0111n + 1（源码三目运算符）0000 0111 + 0000 1000 =8 借助两个2的幂之间的高位是相邻的的方式。然后通过无符号右移使得给定的数高位以后全变成1这样最后进行n+1就获取到了最小大于它的2的幂。至于源码为什么到了16就不操作了，是因为int类型是占4个字节，每个字节8位，共32位。而向右移动16位后，可以从高位第一个出现1的位置开始向右连续32位为1，已经超越了int的最大值，所以不用在进行位移操作了，这也是代码中只是移动16位后就结束的原因。注意：得到的这个capacity却被赋值给了threshold： 1this.threshold = tableSizeFor(initialCapacity); 按理说，应该这么写： 1this.threshold = tableSizeFor(initialCapacity) * this.loadFactor; 但是，请注意，在构造方法中，并没有对table这个成员变量进行初始化，table的初始化被推迟到了put方法中，在put方法中会对threshold进行重新运算。 HashMap是怎么进行扩容的扩容（resize）就是重新计算容量，向HashMap对象里不停的添加元素，而HashMap对象内部的数组无法转载更多的元素时，对象就需要扩大数组的长度，以便能装入更多的元素。当然Java里的数组是无法自动扩容的，方法是使用一个新的数组代替已有的容量小的数组，就像我们用一个小桶装水，如果想装更多的水，就得换大水桶。 resize() 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384final Node&lt;K,V&gt;[] resize() &#123; Node&lt;K,V&gt;[] oldTab = table; int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; int newCap, newThr = 0; if (oldCap &gt; 0) &#123; if (oldCap &gt;= MAXIMUM_CAPACITY) &#123; //如果capcity超过最大阈值了，threshold也设为最大阈值 threshold = Integer.MAX_VALUE; return oldTab; &#125; else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) newThr = oldThr &lt;&lt; 1; // double threshold &#125; else if (oldThr &gt; 0) // initial capacity was placed in threshold //这里便是上面所讲的，一开始将值赋给了threshold,后面将值赋给capacity newCap = oldThr; else &#123; // zero initial threshold signifies using defaults newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); &#125; if (newThr == 0) &#123; //这里有来了一轮threshold的赋值 float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); &#125; threshold = newThr; @SuppressWarnings(&#123;\"rawtypes\",\"unchecked\"&#125;) Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; table = newTab; //非新建hashmap，扩容 if (oldTab != null) &#123; for (int j = 0; j &lt; oldCap; ++j) &#123; Node&lt;K,V&gt; e; if ((e = oldTab[j]) != null) &#123; oldTab[j] = null; //如果在该位置上只有一个值 if (e.next == null) newTab[e.hash &amp; (newCap - 1)] = e; else if (e instanceof TreeNode) ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); else &#123; // preserve order //链表优化重hash Node&lt;K,V&gt; loHead = null, loTail = null; Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; //使用尾插法 do &#123; next = e.next; //lo - 原索引 if ((e.hash &amp; oldCap) == 0) &#123; if (loTail == null) loHead = e; else loTail.next = e; loTail = e; &#125; //hi - 原索引 + oldcap else &#123; if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; &#125; &#125; while ((e = next) != null); //原索引放到bucket里 if (loTail != null) &#123; loTail.next = null; newTab[j] = loHead; &#125; //原索引+oldCap放到bucket里 if (hiTail != null) &#123; hiTail.next = null; newTab[j + oldCap] = hiHead; &#125; &#125; &#125; &#125; &#125; return newTab; &#125; 经过观测可以发现，我们使用的是2次幂的扩展(指长度扩为原来2倍)，所以，元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置。看下图可以明白这句话的意思，n为table的长度，图（a）表示扩容前的key1和key2两种key确定索引位置的示例，图（b）表示扩容后key1和key2两种key确定索引位置的示例，其中hash1是key1对应的哈希与高位运算结果。 元素重新计算hash之后，因为n变为2倍，那么n-1的mask范围在高位多1bit（红色），因此新的index就会发生这样的变化： 因此，我们在扩充HashMap的时候，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap”，可以看看下图为16扩充为32的resize示意图：参考：resize()函数解析 HashMap中的内部类Node类：每个node都含有hash、key、value、next等成员变量 hash：key的hash值 key、value：node的键和值 next：node的下一个node，在产生冲突的时候next才有值 注意Node类重写了equals()和hashCode()方法 12345678910111213141516171819202122232425262728293031323334353637383940static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final int hash; final K key; V value; Node&lt;K,V&gt; next; Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; this.hash = hash; this.key = key; this.value = value; this.next = next; &#125; public final K getKey() &#123; return key; &#125; public final V getValue() &#123; return value; &#125; public final String toString() &#123; return key + \"=\" + value; &#125; //重写了hashCode()方法 public final int hashCode() &#123; return Objects.hashCode(key) ^ Objects.hashCode(value); &#125; public final V setValue(V newValue) &#123; V oldValue = value; value = newValue; return oldValue; &#125; //重写了equals方法，参考 public final boolean equals(Object o) &#123; if (o == this) return true; if (o instanceof Map.Entry) &#123; Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o; if (Objects.equals(key, e.getKey()) &amp;&amp; Objects.equals(value, e.getValue())) return true; &#125; return false; &#125; &#125; Node中存储了key的hash值，键值对，同时还有下一个链表元素。我们重点关注一些equals这个方法，这个方法在什么时候会用到呢？当我们算出的key的hash值相同时，put方法并不会报错，而是继续向这个hash值的链表中添加元素。我们会调用equals方法来比对key和value是否相同，如果equals方法返回false，会继续向链表的尾部添加一个键值对。 未完待续…接下来将会就put和get方法展开源码的阅读…","categories":[{"name":"Java源码","slug":"Java源码","permalink":"wanglilin.github.io/categories/Java源码/"}],"tags":[{"name":"Java源码阅读","slug":"Java源码阅读","permalink":"wanglilin.github.io/tags/Java源码阅读/"},{"name":"Java基础","slug":"Java基础","permalink":"wanglilin.github.io/tags/Java基础/"}]},{"title":"Android-备忘录开发","slug":"android-memo","date":"2017-03-19T06:30:50.000Z","updated":"2017-03-19T06:37:56.566Z","comments":true,"path":"2017/03/19/android-memo/","link":"","permalink":"wanglilin.github.io/blog/2017/03/19/android-memo/","excerpt":"1 前言由于项目需求，最近需要开发一个备忘录，备忘录对于Android是一个很普遍的功能。其实我内心os是每台手机自带的系统就有备忘录功能，在一个App中再开发一个备忘录功能实在是鸡肋。然鹅，做项目就是这样，老板喊做，那我就做着呗。由于为了毕业还要看文献看算法什么的，平时也没什么时间，所以这次只是简单的做了一个可以基于SQLite本地数据库进行备忘录增删查改操作的一个功能。主要实现以下几点功能： 备忘录的增删查改功能 每条备忘录包含标题、内容、时间 备忘录的排列顺序按照时间来，后来居上","text":"1 前言由于项目需求，最近需要开发一个备忘录，备忘录对于Android是一个很普遍的功能。其实我内心os是每台手机自带的系统就有备忘录功能，在一个App中再开发一个备忘录功能实在是鸡肋。然鹅，做项目就是这样，老板喊做，那我就做着呗。由于为了毕业还要看文献看算法什么的，平时也没什么时间，所以这次只是简单的做了一个可以基于SQLite本地数据库进行备忘录增删查改操作的一个功能。主要实现以下几点功能： 备忘录的增删查改功能 每条备忘录包含标题、内容、时间 备忘录的排列顺序按照时间来，后来居上 2 预备知识2.1 SQLite基础在很多项目开发中，我们或多或少都会用到数据库。在Android中，我们一般使用SQLite。因为Android在android.database.sqlite包封装了很多SQLite的API。 继承SQLiteOpenHelper在使用SQLite时，首先创建一个继承SQLiteOpenHelper的类，并重写onCreate()和onUpgrade()方法。 1234567891011121314151617181920212223public class OrderDBHelper extends SQLiteOpenHelper&#123; private static final int DB_VERSION = 1; private static final String DB_NAME = \"myTest.db\"; public static final String TABLE_NAME = \"Orders\"; public OrderDBHelper(Context context) &#123; super(context, DB_NAME, null, DB_VERSION); &#125; @Override public void onCreate(SQLiteDatabase sqLiteDatabase) &#123; // create table Orders(Id integer primary key, CustomName text, OrderPrice integer, Country text); String sql = \"create table if not exists \" + TABLE_NAME + \" (Id integer primary key, CustomName text, OrderPrice integer, Country text)\"; sqLiteDatabase.execSQL(sql); &#125; @Override public void onUpgrade(SQLiteDatabase sqLiteDatabase, int oldVersion, int newVersion) &#123; String sql = \"DROP TABLE IF EXISTS \" + TABLE_NAME; sqLiteDatabase.execSQL(sql); onCreate(sqLiteDatabase); &#125;&#125; 这个类的作用主要是用来创建数据库和建表用，一般来说，我们会再创建一个OrderDao类用于处理所有的数据操作方法。在OrderDao中实例化OrderDBHelper： 1234public OrderDao(Context context) &#123; this.context = context; ordersDBHelper = new OrderDBHelper(context);&#125; SQLite的增删查改操作数据库操作无外乎“增删查改”，我们依据操作是否对数据库有改动将其分为两类： “增删改”对于“增删改”这类对表内容变换的操作，我们需要先调用getWritableDatabase(),执行的时候可以调用通用的excecSQL(String sql)方法或对应的操作API：insert()、delete()、update()。 “查”对于“查”这种对表内容无影响的操作，我们需要调用getReadableDatabase()，这时就不能用execSQL方法，而该改用query()或rawQuery()方法。 增加数据 数据量较多时开启事物进行添加： 1234567891011db = ordersDBHelper.getWritableDatabase();db.beginTransaction();db.execSQL(\"insert into \" + OrderDBHelper.TABLE_NAME + \" (Id, CustomName, OrderPrice, Country) values (1, 'Arc', 100, 'China')\");db.execSQL(\"insert into \" + OrderDBHelper.TABLE_NAME + \" (Id, CustomName, OrderPrice, Country) values (2, 'Bor', 200, 'USA')\");db.execSQL(\"insert into \" + OrderDBHelper.TABLE_NAME + \" (Id, CustomName, OrderPrice, Country) values (3, 'Cut', 500, 'Japan')\");db.execSQL(\"insert into \" + OrderDBHelper.TABLE_NAME + \" (Id, CustomName, OrderPrice, Country) values (4, 'Bor', 300, 'USA')\");db.execSQL(\"insert into \" + OrderDBHelper.TABLE_NAME + \" (Id, CustomName, OrderPrice, Country) values (5, 'Arc', 600, 'China')\");db.execSQL(\"insert into \" + OrderDBHelper.TABLE_NAME + \" (Id, CustomName, OrderPrice, Country) values (6, 'Doom', 200, 'China')\");db.setTransactionSuccessful(); 插入一条新数据可以使用insert(String table, String nullColumnHack, ContentValues values)方法来插入，ContentValues内部实现就是HashMap，但是两者还是有区别的，ContentValues的Key只能存储String类型，Value只能存储基本数据类型以及String类型这些，不能存储对象。 123456789101112db = ordersDBHelper.getWritableDatabase();db.beginTransaction();// insert into Orders(Id, CustomName, OrderPrice, Country) values (7, \"Jne\", 700, \"China\");ContentValues contentValues = new ContentValues();contentValues.put(\"Id\", 7);contentValues.put(\"CustomName\", \"Jne\");contentValues.put(\"OrderPrice\", 700);contentValues.put(\"Country\", \"China\");db.insertOrThrow(OrderDBHelper.TABLE_NAME, null, contentValues);db.setTransactionSuccessful(); 删除数据delete(String table, String WhereClause, String[] WhereArgs),whereClause是删除条件，whereArgs是删除条件值数组 123456db = ordersDBHelper.getWritableDatabase();db.beginTransaction();// delete from Orders where Id = 7db.delete(OrderDBHelper.TABLE_NAME, \"Id = ?\", new String[]&#123;String.valueOf(7)&#125;);db.setTransactionSuccessful(); 修改数据update(String table, ContentValues, String whereClause, String[] whereArgs)： 1234567891011db = ordersDBHelper.getWritableDatabase();db.beginTransaction();// update Orders set OrderPrice = 800 where Id = 6ContentValues cv = new ContentValues();cv.put(\"OrderPrice\", 800);db.update(OrderDBHelper.TABLE_NAME, cv, \"Id = ?\", new String[]&#123;String.valueOf(6)&#125;);db.setTransactionSuccessful(); 查找数据 public Cursor query(String table,String[] columns,String selection,String[] selectionArgs,String groupBy,String having,String orderBy,String limit)query中的参数如下： 参数 含义 table 表名 columns 列名称数组 selection 条件字句，相当于where selectionArgs 条件字句，参数数组 groupBy 分组列 having 分组条件 orderBy 排序列 orderBy 排序列 limit 分页查询限制 cursor 返回值 返回值类型是Cursor，Cursor是一个游标接口，提供了遍历查询结果的方法，如移动指针方法move()，获得列值。Cursor游标常用方法如下： public Cursor rawQuery(String sql, String[] selectionArgs) 类似execSQL方法，不做介绍。 1234567891011121314151617db = ordersDBHelper.getReadableDatabase();// select * from Orders where CustomName = 'Bor'cursor = db.query(OrderDBHelper.TABLE_NAME, ORDER_COLUMNS, \"CustomName = ?\", new String[] &#123;\"Bor\"&#125;, null, null, null);if (cursor.getCount() &gt; 0) &#123; List&lt;Order&gt; orderList = new ArrayList&lt;Order&gt;(cursor.getCount()); while (cursor.moveToNext()) &#123; Order order = parseOrder(cursor); orderList.add(order); &#125; return orderList;&#125; 2.2 FloatingActionButton的使用Floating Action Button（FAB）是众多专家大牛针对Material Design讨论比较细化的一个点，通过圆形元素与分割线、卡片、各种Bar的直线形成鲜明对比，并使用色彩设定中鲜艳的辅色，带来更具突破性的视觉效果。也正因此，在github上，有着许多与FAB相关的开源项目，其具有弹出特效与自动隐藏等功能，虽然本次并没有用到。简单介绍 如何使用： 2.2.1 导入依赖123dependencies &#123; compile 'com.getbase:floatingactionbutton:1.10.1'&#125; 2.2.2 添加View到layout的xml文件中 声明自定义命名空间 1xmlns:fab=\"http://schemas.android.com/apk/res-auto\" 添加com.getbase.floatingactionbutton.FloatingActionButton 1234567891011&lt;com.getbase.floatingactionbutton.FloatingActionButton android:id=\"@+id/add\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_alignParentBottom=\"true\" android:layout_alignParentEnd=\"true\" android:layout_alignParentRight=\"true\" android:layout_margin=\"15dp\" android:src=\"@drawable/ic_add\" fab:fab_colorNormal=\"#37c674\" fab:fab_colorPressed=\"@color/white\" /&gt; 2.2.3 实现弹出菜单功能这次我并没有做弹出菜单功能，只是给button绑定了一个监听器进行activity之间的跳转。如果有需要用到其弹窗功能，可以参考以下链接：FloatingActionButton的使用 2.3 CardView的使用CardView继承自FrameLayout类，是一种卡片视图，以卡片形式显示内容。卡片布局可以设置圆角与阴影，还可以布局其他的View。CardView可以作为一般的布局使用，也可以作为ListView和RecyclerView的Item使用。 2.3.1 导入依赖CardView的位置在supportV7包之中，因此，在使用时，需要导入v7包的依赖。 1compile 'com.android.support:cardview-v7:24.0.0' 2.3.2 CardView属性 android:cardCornerRadius：设置card圆角的大小 android:cardBackgroundColor：设置card的背景颜色 android:elevation：设置阴影的大小 android:contentPadding：设置卡片内容与边界的间隔 android:cardUseCompatPadding：设置内边距，防止内容与边角的重叠 2.3.3 CardView作为listView中单个item的布局用来显示单条备忘录内容的布局： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:card_view=\"http://schemas.android.com/apk/res-auto\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\"&gt; &lt;android.support.v7.widget.CardView android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" card_view:cardCornerRadius=\"6dp\" card_view:cardElevation=\"4dp\" card_view:cardUseCompatPadding=\"true\" card_view:contentPadding=\"10dp\"&gt; &lt;RelativeLayout android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\"&gt; &lt;TextView android:id=\"@+id/note_title\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_alignParentLeft=\"true\" android:layout_alignParentTop=\"true\" android:layout_marginBottom=\"8dp\" android:textColor=\"#ff000000\" android:textSize=\"20sp\" android:textStyle=\"bold\" /&gt; &lt;TextView android:id=\"@+id/note_content\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_below=\"@+id/note_title\" android:layout_marginBottom=\"8dp\" android:textColor=\"#ff000000\" /&gt; &lt;TextView android:id=\"@+id/note_time\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_alignParentBottom=\"true\" android:layout_alignParentRight=\"true\" android:layout_below=\"@+id/note_content\" android:textColor=\"#ff2a0f5c\" android:textSize=\"12sp\" android:textStyle=\"italic\" /&gt; &lt;TextView android:id=\"@+id/note_id\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:visibility=\"gone\" /&gt; &lt;/RelativeLayout&gt; &lt;/android.support.v7.widget.CardView&gt;&lt;/RelativeLayout&gt; 3 备忘录实战3.1 数据库相关类封装3.1.1 NoteOpenHelper继承自SQLiteOpenHelper用于创建数据库及备忘录表，每条记录有4个字段，分别是id（主键，自增）、content（备忘录内容）、title（备忘录标题）、time（备忘录记录时间），其代码如下： 1234567891011121314151617181920212223242526272829303132public class NoteOpenHelper extends SQLiteOpenHelper &#123; public static final String TABLE_NAME = \"note\"; public static final int VERSION = 1; public static final String TITLE = \"title\"; public static final String CONTENT = \"content\"; public static final String TIME = \"time\"; public static final String ID = \"_id\"; public NoteOpenHelper(Context context) &#123; super(context, TABLE_NAME, null, VERSION); &#125; @Override public void onCreate(SQLiteDatabase sqLiteDatabase) &#123; sqLiteDatabase.execSQL(\"create table if not exists \" + TABLE_NAME + \" (\" + ID + \" integer primary key autoincrement,\" + CONTENT + \" text not null,\" + TITLE + \" text not null,\" + TIME + \" text not null)\"); &#125; @Override public void onUpgrade(SQLiteDatabase sqLiteDatabase, int i, int i1) &#123; &#125;&#125;``` 3.1.2 数据库操作类DBManagerSQLite的数据库的增删查改若不经过一番封装，代码将显得冗余不优雅，因此将其封装在一个操作类中，代码如下所示： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106public class DBManger &#123; private Context context; private NoteOpenHelper databaseOpenHelper; private SQLiteDatabase dbReader; private SQLiteDatabase dbWriter; private static DBManger instance; public DBManger(Context context)&#123; this.context = context; databaseOpenHelper = new NoteOpenHelper(context); //创建、打开一个数据库 dbReader = databaseOpenHelper.getReadableDatabase(); dbWriter = databaseOpenHelper.getWritableDatabase(); &#125; /** * getInstance单例 * @param context * @return */ public static synchronized DBManger getInstance(Context context)&#123; if(instance == null)&#123; instance = new DBManger(context); &#125; return instance; &#125; /** * 添加纪录至数据库 * @param title * @param content * @param time */ public void addToDB(String title, String content, String time)&#123; //组装数据 ContentValues cv = new ContentValues(); cv.put(NoteOpenHelper.TITLE, title); cv.put(NoteOpenHelper.CONTENT, content); cv.put(NoteOpenHelper.TIME, time); dbWriter.insert(NoteOpenHelper.TABLE_NAME, null, cv); &#125; /** * 读取数据 * @param noteList */ public void readFromDB(List&lt;Note&gt; noteList)&#123; Cursor cursor = dbReader.query(NoteOpenHelper.TABLE_NAME, null, null, null, null, null, null); try&#123; while(cursor.moveToNext())&#123; Note note = new Note(); note.setId(cursor.getInt(cursor.getColumnIndex(NoteOpenHelper.ID))); note.setTitle(cursor.getString(cursor.getColumnIndex(NoteOpenHelper.TITLE))); note.setContent(cursor.getString(cursor.getColumnIndex(NoteOpenHelper.CONTENT))); note.setTime(cursor.getString(cursor.getColumnIndex(NoteOpenHelper.TIME))); noteList.add(note); &#125; cursor.close(); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; &#125; /** * 更新数据 * @param noteID * @param title * @param content * @param time */ public void updateNote(int noteID, String title, String content, String time) &#123; ContentValues cv = new ContentValues(); cv.put(NoteOpenHelper.ID, noteID); cv.put(NoteOpenHelper.TITLE, title); cv.put(NoteOpenHelper.CONTENT, content); cv.put(NoteOpenHelper.TIME, time); dbWriter.update(NoteOpenHelper.TABLE_NAME, cv, \"_id = ?\", new String[]&#123;noteID + \"\"&#125;); &#125; /** * 删除数据 * @param noteID */ public void deleteNote(int noteID) &#123; dbWriter.delete(NoteOpenHelper.TABLE_NAME, \"_id = ?\", new String[]&#123;noteID + \"\"&#125;); &#125; /** * 根据ID查询数据 * @param noteID * @return */ public Note readData(int noteID) &#123; Cursor cursor = dbReader.rawQuery(\"SELECT * FROM note WHERE _id = ?\", new String[]&#123;noteID + \"\"&#125;); Note note = new Note(); System.out.println(\"database:cursor:\" + cursor); if(cursor != null &amp;&amp; cursor.moveToFirst())&#123; note.setId(cursor.getInt(cursor.getColumnIndex(NoteOpenHelper.ID))); note.setTitle(cursor.getString(cursor.getColumnIndex(NoteOpenHelper.TITLE))); note.setContent(cursor.getString(cursor.getColumnIndex(NoteOpenHelper.CONTENT))); &#125; return note; &#125;&#125; 3.2 备忘录列表listView适配器这个就没什么好说的了，为了提高性能，用了ViewHolder。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172public class MyAdapter extends BaseAdapter &#123; private Context context; private List&lt;Note&gt; notes; public MyAdapter(Context context, List&lt;Note&gt; notes) &#123; this.context = context; //实现倒序排列 Collections.reverse(notes); this.notes = notes; &#125; public void removeAllItem() &#123; notes.clear(); notifyDataSetChanged(); &#125; public void removeItem(int position) &#123; notes.remove(position); notifyDataSetChanged(); &#125; @Override public int getCount() &#123; return notes.size(); &#125; @Override public Note getItem(int i) &#123; return notes.get(i); &#125; @Override public long getItemId(int i) &#123; return i; &#125; @Override public View getView(int position, View convertView, final ViewGroup parent) &#123; ViewHolder viewHolder; if (convertView == null)&#123; convertView = LayoutInflater.from(context).inflate(R.layout.item_note, null); viewHolder = new ViewHolder(); viewHolder.tvTitle = (TextView) convertView.findViewById(R.id.note_title); viewHolder.tvContent = (TextView) convertView.findViewById(R.id.note_content); viewHolder.tvTime = (TextView) convertView.findViewById(R.id.note_time); &#125; else &#123; viewHolder = (ViewHolder) convertView.getTag(); &#125; viewHolder.setId(notes.get(position).getId()); viewHolder.tvTitle.setText(notes.get(position).getTitle()); viewHolder.tvContent.setText(notes.get(position).getContent()); viewHolder.tvTime.setText(notes.get(position).getTime()); convertView.setTag(viewHolder); return convertView; &#125; public static class ViewHolder &#123; public int Id; public TextView tvTitle; public TextView tvContent; public TextView tvTime; public void setId(int id) &#123; Id = id; &#125; &#125;&#125; 3.3 主界面和编辑界面3.3.1 主界面主界面布局： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:fab=\"http://schemas.android.com/apk/res-auto\" android:orientation=\"vertical\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;include android:layout_width=\"fill_parent\" android:layout_height=\"@dimen/head_h\" layout=\"@layout/inc_head\" /&gt; &lt;RelativeLayout android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:fitsSystemWindows=\"true\"&gt; &lt;ListView android:id=\"@+id/list\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:divider=\"@null\"&gt;&lt;/ListView&gt; &lt;TextView android:id=\"@+id/empty\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_centerVertical=\"true\" android:gravity=\"center\" android:text=\"点击右下方图标添加备忘\" android:textSize=\"16sp\" /&gt; &lt;com.getbase.floatingactionbutton.FloatingActionButton android:id=\"@+id/add\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_alignParentBottom=\"true\" android:layout_alignParentEnd=\"true\" android:layout_alignParentRight=\"true\" android:layout_margin=\"15dp\" android:src=\"@drawable/ic_add\" fab:fab_colorNormal=\"#37c674\" fab:fab_colorPressed=\"@color/white\" /&gt; &lt;/RelativeLayout&gt;&lt;/LinearLayout&gt; 主要是一个Listview和FAB，以及一个TextView，用以在当没有备忘录条目时，默认提示“点击右下方按钮增加备忘”。 Activity：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102public class ChiefNotepadActivity extends BaseActivity &#123; private FloatingActionButton addBtn; private TextView emptyListTextView; private DBManger dm; private List&lt;Note&gt; noteDataList = new ArrayList&lt;&gt;(); private MyAdapter adapter; private ListView listView; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_chief_notepad); setTitle(\"备忘录\"); initHead(R.drawable.ic_head_back, 0); initNotePad(); &#125; private void initNotePad() &#123; dm = new DBManger(this); dm.readFromDB(noteDataList); listView = (ListView) findViewById(R.id.list); addBtn = (FloatingActionButton) findViewById(R.id.add); emptyListTextView = (TextView) findViewById(R.id.empty); addBtn.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; Intent i = new Intent(ChiefNotepadActivity.this, ChiefEditNoteActivity.class); i.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP); startActivity(i); &#125; &#125;);// adapter = new MyAdapter(this, noteDataList); adapter = new MyAdapter(this, noteDataList); listView.setAdapter(adapter); listView.setOnItemClickListener(new NoteClickListener()); listView.setOnItemLongClickListener(new NoteLongClickListener()); updateView(); &#125; //listView单击事件 private class NoteClickListener implements AdapterView.OnItemClickListener&#123; @Override public void onItemClick(AdapterView&lt;?&gt; adapterView, View view, int i, long l) &#123; MyAdapter.ViewHolder viewHolder = (MyAdapter.ViewHolder) view.getTag(); int noteId = viewHolder.Id; Intent intent = new Intent(ChiefNotepadActivity.this, ChiefEditNoteActivity.class); intent.putExtra(\"id\", noteId); startActivity(intent); &#125; &#125; //listView长按事件 private class NoteLongClickListener implements AdapterView.OnItemLongClickListener &#123; @Override public boolean onItemLongClick(AdapterView&lt;?&gt; adapterView, View view, final int i, long l) &#123; final Note note = ((MyAdapter) adapterView.getAdapter()).getItem(i); if (note == null) &#123; return true; &#125; final int id = note.getId(); new MaterialDialog.Builder(ChiefNotepadActivity.this) .content(\"确定删除此条笔记？\") .positiveText(\"确定\") .negativeText(\"取消\") .callback(new MaterialDialog.ButtonCallback()&#123; @Override public void onPositive(MaterialDialog dialog) &#123; DBManger.getInstance(ChiefNotepadActivity.this).deleteNote(id); adapter.removeItem(i); updateView(); &#125; &#125;).show(); return true; &#125; &#125; //数据更新 private void updateView() &#123; if (noteDataList.isEmpty()) &#123; listView.setVisibility(View.GONE); emptyListTextView.setVisibility(View.VISIBLE); &#125; else &#123; listView.setVisibility(View.VISIBLE); emptyListTextView.setVisibility(View.GONE); &#125; &#125;&#125; 主要是初始化和三个监听事件函数： 点击addBtn时，跳转至编辑界面 短按listView中的条目时，跳转至编辑界面，修改备忘录内容界面 长按listView中的条目时，弹窗，提示是否删除该条备忘录 其中在跳转界面时，给Intent设置标志FLAG_ACTIVITY_CLEAR_TOP的原因在于,怕用户在主界面与编辑界面之间反复跳转时，会在栈中存留多个activity界面，而影响用户体验。 3.3.2 编辑界面界面布局： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:fab=\"http://schemas.android.com/apk/res-auto\" android:orientation=\"vertical\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;include android:layout_width=\"fill_parent\" android:layout_height=\"@dimen/head_h\" layout=\"@layout/inc_head\" /&gt; &lt;RelativeLayout android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:fitsSystemWindows=\"true\" android:orientation=\"vertical\"&gt; &lt;EditText android:id=\"@+id/note_title\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:hint=\"请输入备忘标题\" android:maxLength=\"50\" android:textSize=\"@dimen/news_item_title_textsize\" android:maxLines=\"1\"&gt; &lt;requestFocus /&gt; &lt;/EditText&gt; &lt;EditText android:id=\"@+id/note_content\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:layout_alignParentBottom=\"true\" android:layout_alignParentLeft=\"true\" android:layout_alignParentStart=\"true\" android:layout_below=\"@+id/note_title\" android:gravity=\"start\" android:hint=\"请在此输入备忘内容\" android:inputType=\"textMultiLine\" /&gt; &lt;ImageView android:id=\"@+id/note_image\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_below=\"@+id/save\" /&gt; &lt;com.getbase.floatingactionbutton.FloatingActionButton android:id=\"@+id/save\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_alignParentBottom=\"true\" android:layout_alignParentEnd=\"true\" android:layout_alignParentRight=\"true\" android:layout_margin=\"15dp\" android:src=\"@drawable/ic_action_save\" fab:fab_colorNormal=\"#37c674\" fab:fab_colorPressed=\"@color/white\" /&gt; &lt;/RelativeLayout&gt;&lt;/LinearLayout&gt; 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788package com.zju.hzsz.chief.activity;import android.content.Intent;import android.os.Bundle;import android.text.Selection;import android.text.Spannable;import android.view.View;import android.widget.EditText;import com.getbase.floatingactionbutton.FloatingActionButton;import com.zju.hzsz.R;import com.zju.hzsz.db.DBManger;import com.zju.hzsz.model.Note;import java.util.Date;/** * Created by Wangli on 2017/3/8. */public class ChiefEditNoteActivity extends BaseActivity &#123; private EditText titleEt; private EditText contentEt; private FloatingActionButton saveBtn; private int noteID = -1; private DBManger dbManger; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_chief_editnote); setTitle(\"编辑备忘\"); initHead(R.drawable.ic_head_back, 0); initEditNotePad(); &#125; private void initEditNotePad() &#123; dbManger = new DBManger(this); titleEt = (EditText) findViewById(R.id.note_title); contentEt = (EditText) findViewById(R.id.note_content); saveBtn = (FloatingActionButton) findViewById(R.id.save); saveBtn.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; String title = titleEt.getText().toString(); String content = contentEt.getText().toString(); String time = getTime(); //将最新修改的放最前面 if ( noteID != -1) &#123; dbManger.deleteNote(noteID); &#125; dbManger.addToDB(title, content, time); Intent i = new Intent(ChiefEditNoteActivity.this, ChiefNotepadActivity.class); i.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP); startActivity(i); finish(); &#125; &#125;); noteID = getIntent().getIntExtra(\"id\", -1); if (noteID != -1) &#123; showNoteData(noteID); &#125; &#125; private void showNoteData(int noteID) &#123; Note note = dbManger.readData(noteID); titleEt.setText(note.getTitle()); contentEt.setText(note.getContent()); //控制光标 Spannable spannable = titleEt.getText(); Selection.setSelection(spannable, titleEt.getText().length()); &#125; private String getTime() &#123; java.text.SimpleDateFormat format = new java.text.SimpleDateFormat(\"MM-dd HH:mm E\"); Date curDate = new Date(); String str = format.format(curDate); return str; &#125;&#125; 以及Note类： 123456789101112131415161718192021222324252627282930313233343536373839public class Note &#123; public int noteId; public String title; public String content; public String time; public String getContent() &#123; return content; &#125; public void setContent(String content) &#123; this.content = content; &#125; public int getId() &#123; return noteId; &#125; public void setId(int id) &#123; this.noteId = id; &#125; public String getTime() &#123; return time; &#125; public void setTime(String time) &#123; this.time = time; &#125; public String getTitle() &#123; return title; &#125; public void setTitle(String title) &#123; this.title = title; &#125;&#125; 值得一说的是，将listView倒序排列。用到的语句是： 1Collections.reverse(List&lt; ? &gt;); 以及重新编辑一条备忘之后，要将这条备忘的原记录删除，再将新编辑后的备忘置顶。 整个开发流程，大致就是这样。 上两张图吧：","categories":[{"name":"Android","slug":"Android","permalink":"wanglilin.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"wanglilin.github.io/tags/Android/"}]},{"title":"Java基础之异常","slug":"java-exception","date":"2017-03-11T12:51:50.000Z","updated":"2017-03-11T13:17:27.612Z","comments":true,"path":"2017/03/11/java-exception/","link":"","permalink":"wanglilin.github.io/blog/2017/03/11/java-exception/","excerpt":"前言 A clever person solves a problem, a wise person avoids it.&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; ——那你，会如何处理异常，try or throw？ 1 异常是什么我有一辆车（不是自行车，四轮的！！诶，更不是拖拉机！！！），我要开车去隔壁村见小王（不是隔壁老王），开到半路爆胎了，此时，我有两个选择： 如果我车上有备胎（诶，可惜我备胎这东西是建立在有女朋友的基础之上的，女朋友是个好东西，然而我并没有），我可以选择在当前就换个轮胎，然后将坏了的车胎放到后备箱，车子仍然可以继续开； 我车上没有备胎，那我只能放个警示牌，打个电话给能处理这个车爆胎的人来处理，而这并不妨碍我走着去见隔壁村的小王。 这就是在Java中遇到异常的两个常用的方法，你可以处理它（try）或抛出它（throw），即将锅交给别人去处理。","text":"前言 A clever person solves a problem, a wise person avoids it.&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; ——那你，会如何处理异常，try or throw？ 1 异常是什么我有一辆车（不是自行车，四轮的！！诶，更不是拖拉机！！！），我要开车去隔壁村见小王（不是隔壁老王），开到半路爆胎了，此时，我有两个选择： 如果我车上有备胎（诶，可惜我备胎这东西是建立在有女朋友的基础之上的，女朋友是个好东西，然而我并没有），我可以选择在当前就换个轮胎，然后将坏了的车胎放到后备箱，车子仍然可以继续开； 我车上没有备胎，那我只能放个警示牌，打个电话给能处理这个车爆胎的人来处理，而这并不妨碍我走着去见隔壁村的小王。 这就是在Java中遇到异常的两个常用的方法，你可以处理它（try）或抛出它（throw），即将锅交给别人去处理。 “异常”这个词通常有“我对此感到很意外”的意思。问题出现了，你也许不清楚该如何处理，但你的确知道不应该置之不理；你要停下来，看看是不是有别人或在别的地方，能够处理这个问题。只是在当前的环境中，还没有足够的信息来解决这个问题，所以就把这个问题提交到一个更高级别的环境中，在那里将做出正确的决定。&emsp;&emsp;&emsp;——《Java编程思想》 P248 异常指不期而遇的各种状况，如：文件找不到、网络连接失败，非法参数等。异常是一个事件，它发生在程序运行期间，干扰了正常的指令流程。Java通过API中Throwable类的众多子类描述各种不同的异常。因而，Java异常都是对象，是Throwable子类的实例。Java异常类的层次结构图如下： Throwable：Java语言中所有错误或异常的超类，有两个重要的子类，Exception（异常）和Error（错误），二者都是Java异常处理的重要子类，各自都包含大量子类。 Error：表示仅靠程序本身无法恢复的严重错误。与代码编写者无关，是代码运行时JVM出现的错误，发生于虚拟机自身、或者发生在虚拟机试图执行应用时，如Java虚拟机运行错误（VirtualMachineError）、类定义错误（NoClassDefFoundError）等。这些错误都是不可查的，因为他们在应用程序的控制和处理能力之外，而且绝大多数是程序运行时不允许出现的状况。 Exception：表示程序本身可以处理的异常。 RuntimeException：那些可能在Java虚拟机正常运行期间抛出的异常的超类。Java编译器不去检查它，也就是说，当程序中可能出现这类异常时，即使没有用try...catch语句捕获它，也没有用throws子句声明抛出它，也还是会编译通过。例如：若试图使用空值对象引用、除数为零或数组越界，则分别引发运行时异常（NullPointerException/ArithmeticException/ArrayIndexOutOfBoundException）。 CheckedException：正确的程序在运行中，很容易出现的、情理可容的异常状况，可查异常状况虽然是异常状况，但在一定程度上它的发生是可以预计的，而且一旦发生这种异常状况，就必须采取某种方式进行处理。即Java编译器会检查它，也就是说，当程序中可能出现这类异常，要么用try-catch语句捕获它，要么用throws字句声明抛出它，否则编译不会通过。如IOException/SQLException等。 PS：Java中RuntimeException这个类名起的并不恰当，因为任何异常都是运行时出现的。（在编译时出现的错误并不是异常，换句话说，异常就是为了解决程序运行时出现的的错误）。 PPS：如何区分，如果出现RuntimeException，那么一定是程序员的错误。例如，可以通过检查数组下标和数组边界来避免数组越界访问异常。 非RutimeException一般是外部错误，例如试图从文件尾后读取数据等，这并不是程序本身的错误，而是在应用环境中出现的外部错误。 2 异常处理机制 异常机制是指当程序出现错误后，程序如何处理。具体来说，异常机制提供了程序退出的安全通道。当出现错误后，程序执行的流程发生改变，程序的控制权转移到异常处理器。在Java应用程序中，异常处理机制为：抛出异常、捕获异常。异常处理的流程： 遇到错误，方法立即结束，并不返回一个值；同时，抛出一个异常对象 。 调用该方法的程序也不会继续执行下去，而是搜索一个可以处理该异常的异常处理器，并执行其中的代码。 2.1 try-catch 抛出异常： 当遇到异常情形时，程序无法继续向下执行，因为在当前的环境下无法获得必要的信息来解决问题。只能从当前环境跳出，将问题提交至上一级环境。当抛出异常后，会有几件事情随之发生： 将使用new在堆上创建异常对象。 当前的执行路径（它不能继续下去了）被终止，并且从当前环境中弹出对异常对象的引用。 异常处理机制接管程序，并开始寻找一个恰当的地方来执行程序。这个恰当的地方就是异常处理程序，它的任务是将程序从错误状态中恢复，以使程序要么换一种方式运行，要么继续运行下去。 捕获异常： Java中，异常的捕获通常通过try-catch或try-catch-finally语句实现，即监控区域（一段可能产生异常的代码+处理这些异常的代码） try块：如果在方法内部抛出了异常，这个方法将在抛出异常的过程中结束。要是不希望方法就此结束，可以在方法内设置一个特殊的块来捕获异常。因为在这块里，尝试了各种可能产生异常的方法的调用，所以称为try块。它是跟在try关键字之后的普通程序块： 123try&#123; //code that might generate exceptions&#125; catch子句： 抛出的异常必须在某处得到处理。这个地点就是异常处理程序，而且针对每个要捕获的异常，得准备相应的处理程序。异常程序紧跟在try块之后，以关键字catch表示： 123456789try&#123; // code that might generate exceptions&#125;catch(Type id1)&#123; //Handle exceptions of Type1&#125;catch(Type id2)&#123; //Handle exceptions of Type2&#125;catch(Type id3)&#123; //Handle exceptions of Type3&#125; 每个catch子句看起来就像是接收一个且仅接受一个特殊类型的参数的方法。当异常被抛出后，异常处理机制将负责搜寻参数与异常类型相匹配的第一个处理程序，然后进入catch子句之中执行。只有匹配的catch子句才能得到执行。异常匹配的原则是：如果抛出的异常对象属于catch子句的异常类，或者该异常类的子类，则认为生成的异常类对象与catch块捕获的异常类型相匹配。下面举个例子： 捕获throw语句抛出的“除数为0”异常 12345678910111213141516public class TestException &#123; public static void main(String[] args)&#123; int a = 1; int b = 0; try&#123; if (b == 0) &#123; throw new ArithmeticException(); &#125; System.out.println(\"a/b的值是：\" + a / b); &#125;catch(ArithmeticException e)&#123; System.out.println(\"变量b不能为0\"); &#125; System.out.println(\"程序正常结束\"); &#125;&#125; 运行结果：变量b不能为0程序正常结束 事实上，“除数为0”等ArithmeticException，是RuntimeException的子类，而运行时异常将由运行时系统自动抛出，不需要使用throw语句。故可将代码改成如下形式：12345678910111213public class TestException &#123; public static void main(String[] args)&#123; int a = 1; int b = 0; try&#123; System.out.println(\"a/b的值是：\" + a / b); &#125;catch(ArithmeticException e)&#123; System.out.println(\"变量b不能为0\"); &#125; System.out.println(\"程序正常结束\"); &#125;&#125; 运行结果： 变量b不能为0程序正常结束 由于检查运行时异常的代价远大于捕捉异常所带来的益处，Java编译器允许忽略运行时异常，一个方法可以既不捕捉，也不声明抛出运行时异常。如下代码所示：1234567public class TestException &#123; public static void main(String[] args)&#123; int a = 1; int b = 0; System.out.println(\"a/b的值是：\" + a / b); &#125;&#125; 运行结果： Exception in thread “main” java.lang.ArithmeticException: / by zero 2.1.1 catch子句注意事项 一旦某个catch子句捕获到匹配的异常类型，将进入异常处理代码。一经处理结束，就意味着整个try-catch语句结束。其他的catch子句不再有匹配和捕获异常类型的机会。 Java通过异常类描述异常类型，对于有多个catch子句的异常程序而言，应该尽量将捕获底层异常类的catch子句放在前面，同时尽量将捕获相对高层的异常类的catch子句放在后面。否则，捕获底层异常类的catch子句可能会被屏蔽。 RuntimeException异常类包括运行时各种常见的异常，ArithmeticException类和ArrayIndexOutOfBoundsException类都是它的子类。因此，RuntimeException异常类的catch子句应该放在最后面，否则可能会屏蔽其后的特定异常处理或引起编译错误。 2.2 try-catch-finallytry-catch语句还可以包括第三部分，就是finally子句。它表示无论是否出现异常，都应该执行的内容，try-catch-finally语句的一般语法形式如下： 1234567891011try&#123; // code that might generate exceptions&#125;catch(Type id1)&#123; //Handle exceptions of Type1&#125;catch(Type id2)&#123; //Handle exceptions of Type2&#125;catch(Type id3)&#123; //Handle exceptions of Type3&#125;finally&#123; //Activities that happen every time&#125; 对于一些代码，可能会希望无论try块中的异常是否抛出，它们都能得到执行。图示如下：这通常适用于内存回收之外的情况（因为回收由垃圾回收器完成）。为了达到这个效果，可以在异常处理程序后面架上finally子句。如下例所示： 1234567891011121314151617public class TestException &#123; public static void main(String args[]) &#123; int i = 0; String greetings[] = &#123; \" Hello world !\", \" Hello World !! \", \" HELLO WORLD !!!\" &#125;; while (i &lt; 4) &#123; try &#123; // 特别注意循环控制变量i的设计，避免造成无限循环 System.out.println(greetings[i++]); &#125; catch (ArrayIndexOutOfBoundsException e) &#123; System.out.println(\"数组下标越界异常\"); &#125; finally &#123; System.out.println(\"--------------------------\"); &#125; &#125; &#125; &#125; 2.2.1 finally子句注意事项 对于没有垃圾回收和析构函数自动调用机制的语言来说，finally非常重要。它能使程序员保证：无论try块里发生了什么，内存总能得到释放。但Java有垃圾回收机制，所以内存释放不再是问题。而且，Java也没有析构函数可供调用。在Java中，用到finallyde情况主要是在，当要把除内存之外的资源恢复到它们的初始状态时。这种需要清理的资源包括：已经打开的文件或网络连接，在屏幕上画的图形，甚至可以是外部世界的某个开关。 当在try块或catch块中遇到return语句时，finally语句块将在方法返回之前被执行。 finally语句块不能给变量赋新值来改变return的返回值，也不建议在finally块中使用return语句。没有意义还容易造成混淆。 2.3 throw/throws任何Java代码都可以抛出异常，如：自己编写的代码、来自Java开发环境包中的代码，或者Java运行时系统。Java对于处理不了的异常或者要转型的异常，一般用throw/throws语句抛出异常。如果一个方法没有捕获一个检查性异常，那么该方法必须使用throws关键字来声明。throws关键字放在方法签名的尾部，也可以使用throw关键字抛出一个异常，无论它是新实例化的还是刚捕获到的。 2.3.1 throws如果与一个方法可能会出现异常，但没有能力处理这种异常，可以在方法声明处用throws子句来声明抛出异常。就好像，初中时经常会有打架时间，几个人打一个人，这个人被打之后，想报仇又无力报仇，所以叫一帮兄弟帮他报仇。throws语句用在方法定义时声明该方法要抛出的异常类型，如果抛出的是Exception异常类型，则该方法被声明为抛出所有de异常；多个异常用逗号分隔，throws语句的语法格式如下： 123methodName throws Exception1, Exception2, Exception3&#123;&#125; throws后为声明要抛出的异常列表。当方法抛出异常列表中的异常的时候，方法将不对这些类型及其子类型进行异常处理，而将异常抛向调用该方法的方法。举例如下： 123456789101112131415import java.lang.Exception; public class TestException &#123; static void pop() throws NegativeArraySizeException &#123; // 定义方法并抛出NegativeArraySizeException异常 int[] arr = new int[-3]; // 创建数组 &#125; public static void main(String[] args) &#123; // 主方法 try &#123; // try语句处理异常信息 pop(); // 调用pop()方法 &#125; catch (NegativeArraySizeException e) &#123; System.out.println(\"pop()方法抛出的异常\");// 输出异常信息 &#125; &#125; &#125; pop方法没有处理异常NegativeArraySizeException，而是由main函数来处理。 throws抛出异常的规则： 如果是不可检查异常（Unchecked Exception），即Error、RuntimeException或它们的子类，那么可以不使用throws关键字来声明要抛出的异常，编译仍然能通过，但运行时会被系统抛出。 必须声明方法可抛出的任何可查异常（Checked Exception），即如果一个方法可能出现可查异常，要么用try-catch语句捕获，要么用throws语句声明将它抛出，否则会导致编译错误。 该方法的调用者必须处理或者重新抛出该异常。当方法的调用者无力处理该异常的时候，应该继续抛出，而不是囫囵吞枣。 调用方法必须遵循任何可查异常的处理和声明规则。若覆盖一个方法，则不能声明与覆盖方法不同的异常。声明的任何异常必须是被覆盖方法所声明异常的同类或子类。 2.3.2 throwthrow总是出现在函数体中，用来抛出一个Throwable的异常，程序会在throw语句后立即终止，它后面的语句总是执行不到的。异常是异常类的实力对象，我们可以创建异常类的实例对象通过throw语句抛出，该语句的语法格式如下：1throw new ExceptionName(); 如果抛出了检查异常，则还应该在方法头部声明方法可能抛出的异常类型。该方法的调用者也必须检查处理抛出的异常，如果所有方法都层层上抛获取的异常，最终JVM会进行处理。处理方式也很简单，即打印异常消息和堆栈消息。 2.3.3 Throwable类中的常用方法catch关键字后面括号中的Exception类型的参数e。Exception就是try代码块传递给catch代码块的变量类型，e就是变量名。通常异常处理常用3个函数来获取异常的有关信息：getCause(): 返回抛出异常的原因。如果 cause 不存在或未知，则返回 null。getMeage(): 返回异常的消息信息。printStackTrace(): 对象的堆栈跟踪输出至错误输出流，作为字段 System.err 的值。 有时为了简单会忽略掉catch语句后的代码，这样try-catch语句就成了一种摆设，一旦程序在运行过程中出现了异常，就会忽略处理异常，而错误发生的原因很难查找。 3 自定义异常所谓自定义异常，通常就是指定义了一个继承自Exception类的子类，那么这个类就是一个自定义异常类。通常情况下，我们都会继承自Exception类，一般不会继承某个运行时的异常类。基于特定的需求，自定义异常在项目中的使用还是很普遍的。 自定义异常类MyException： 1234567891011public class MyException extends Exception &#123; public MyException()&#123; super(); &#125; public MyException(String messeage)&#123; super(messeage); &#125;&#125; 当然也可选用Throwable作为父类。其中无参数构造器为创建缺省参数对象提供了方便。第二个构造器将在创建这个异常对象时提供描述这个异常信息的字符串，通过调用父类构造器向上传递给父类，对父类中的toString()方法中返回的原有信息进行覆盖。作为该异常的异常信息。 测试自定义异常类代码： 1.抛出异常throws：12345678910111213141516171819public class ExxceptionTest &#123; public void method(String string) throws MyException &#123; if (null == string)&#123; throw new MyException(\"传入的字符串参数不能为null\"); &#125;else &#123; System.out.println(string); &#125; &#125; public static void main(String[] args) throws MyException &#123; ExxceptionTest test = new ExxceptionTest(); test.method(null); &#125;&#125; 运行结果：Exception in thread “main” MyException: 传入的字符串参数不能为null at ExxceptionTest.method(ExxceptionTest.java:9) at ExxceptionTest.main(ExxceptionTest.java:29) …… 2.处理异常try-catch：123456789101112131415161718192021222324252627public class ExceptionTest &#123; public void method(String string) throws MyException &#123; if (null == string)&#123; throw new MyException(\"传入的字符串参数不能为null\"); &#125;else &#123; System.out.println(string); &#125; &#125; public static void main(String[] args) &#123; try&#123; ExceptionTest test = new ExceptionTest(); test.method(null); &#125;catch (MyException e)&#123; //将错误信息在System.out流中打印出来 e.printStackTrace(System.out); &#125;finally &#123; System.out.println(\"异常处理完毕\"); &#125; System.out.println(\"程序执行完毕\"); &#125;&#125; 运行结果：MyException: 传入的字符串参数不能为null at ExxceptionTest.method(ExceptionTest.java:9) at ExxceptionTest.main(ExceptionTest.java:19) ….异常处理完毕程序执行完毕 毋庸置疑，我们不可能期待JVM自动抛出一个自定义异常，也不能够期待JVM会自动处理一个自定义异常。发现异常、抛出异常以及处理异常的工作必须靠编程人员在代码中利用异常处理机制自己完成。而打印异常处理信息可以在抛出时包括在构造器的参数中，或者包括在处理这个异常的catch中。 不定期更新…","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"wanglilin.github.io/categories/JavaSE/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"wanglilin.github.io/tags/Java基础/"},{"name":"JavaSE","slug":"JavaSE","permalink":"wanglilin.github.io/tags/JavaSE/"}]},{"title":"Java基础之字符串","slug":"javase-string","date":"2017-03-04T08:08:41.000Z","updated":"2017-03-11T13:09:38.106Z","comments":true,"path":"2017/03/04/javase-string/","link":"","permalink":"wanglilin.github.io/blog/2017/03/04/javase-string/","excerpt":"类结构public final class Stringextends Objectimplements Serializable, Comparable, CharSequence 类概述Java把内存划分为两种：一种是栈内存，一种是堆内存。在函数中定义的一些基本类型的变量和对象的引用变量都是在函数的栈内存中分配。当在一段代码块定义一个变量时，Java就在栈中为这个变量分配内存空间，当超过变量的作用域后，Java会自动释放掉为该变量分配的内存空间，该内存空间可以立即被另作它用。","text":"类结构public final class Stringextends Objectimplements Serializable, Comparable, CharSequence 类概述Java把内存划分为两种：一种是栈内存，一种是堆内存。在函数中定义的一些基本类型的变量和对象的引用变量都是在函数的栈内存中分配。当在一段代码块定义一个变量时，Java就在栈中为这个变量分配内存空间，当超过变量的作用域后，Java会自动释放掉为该变量分配的内存空间，该内存空间可以立即被另作它用。 堆内存用来存放由new创建的对象和数组，在堆中分配的内存，由Java虚拟机的自动垃圾回收器来管理。在堆中产生了一个数组或者对象之后，还可以在栈中定义一个特殊的变量，让栈中的这个变量的取值等于数组或对象在堆内存中的首地址，栈中的这个变量就成了数组或对象的引用变量（以后就可以在程序中使用栈中的引用变量来访问堆中的数组或者对象，引用变量相当于是为数组或者对象起的一个名称）。 PS：引用变量是普通的变量，定义时在栈中分配，引用变量在程序运行到其作用域之外后被释放。而数组和对象本身在堆中分配，引用变量在程序运行到其作用域之外后被释放。而数组和对象本身在堆中分配，即使程序运行到使用new产生的数组或者对象所在的代码块之外，数组和对象本身占据的内存不会被释放，数组和对象在没有引用变量指向它的时候，才变为垃圾，不能再被使用，但仍然占据内存空间不放，在随后的一个不确定的时间被垃圾回收器收走（释放）。- &gt;这也是Java比较占内存的原因。 String类是一个很特殊的类，它本身是final的，它是不可变的，String类是的本质是字符数组char[], 并且其值不可改变,但StringBuilder也是final，为什么StringBuilder是可变的呢？ 究其原因，String类的内部是char[]数组构成，而String的加号（+）运算符的底层是由StringBuilder实现的，一个String每次“+“上一个String,都会创建一个新的StringBuilder，然后调用它的append()方法，该方法返回一个新形成的String。所以字符串的一些合并操作可以使用StringBuilder来提高效率。 用new String()创建的字符串不是常量，不能在编译期就确定，而因为String是类，所以new String()创建的字符串不放入常量池中，它们有自己的地址空间。即Java中，只要使用new关键字来创建对象，则一定会（在堆区或栈区）创建一个新的对象。而直接初始化则会形成字符串常量，分配到运行时常量池中，这会在编译时确定。 小结 Java程序中的所有字面值（string literals），即双引号括起来的字符串，如“bia”，都是作为String类的实例实现的。 String类是一个很特殊的类，它本身是final的，它是不可变的，String类的本质是字符数组char[ ]， 并且其值不可改变。String是常量，其对象一旦构造就不能被改变。In other words，String对象是不可变的，每一个看起来会修改String值的方法，实际上都是创造了一个全新的String对象（构建一个新的StringBuilder，然后调用它的append()方法，该方法方法返回一个新创建的String对象），以包含修改后的字符串内容。 String对象具有只读特性，指向它的任何引用都不可能改变它的值，因此，也不会对其他的引用有什么影响。 方法1.创建字符串 12345String str = \"Hello World\";String str1 = new String(\"Hello World\");String str2 = new String();str2 = \"Hello World\"System.out.println(\"str:\" + str + \"str1:\" + str1 + \"str2:\" + str2); String类有11种构造方法，这些方法提供不同的参数来初始化字符串 String类是不可改变的，所以一旦创建了String对象，其值就无法改变了 2.字符串长度 123String str = \"Hello World\";int i = str.length();System.out.println(i); String类的一个访问器方法是length( )方法，它返回字符串对象包含的字符数。 3.连接字符串 字符串常量使用concat( )方法连接 使用’+’操作符来连接字符串 1234String str = \"Hello World\";String str1 = \"Good Friends\";str2 = str.concat(str1);str3 = str + str1; 4.创建格式化字符串 1234567String str;int i = 100;double d = 10.243;float f = 124124;str = String.format(\"NO1 : %d\" + \"NO2 : %f\" + \"NO3 : %f\",i,f,d); //使用 .format() 方法格式化字符串System.out.printf(\"NO1 : %d\" + \"NO2 : %f\" + \"NO3 : %f\",i,f,d); //使用 printf()方法 格式化字符串System.out.println(str); 我们知道输出格式化数字可以使用printf( )和format( )方法。String类使用静态方法format( )返回一个String对象而不是PrintStream对象。String类的静态方法format( )能用来创建可复用的格式化字符串，而不仅仅是用于一次打印输出。 5.char charAt(int index)返回指定索引处的char值12345String str = \"hello world\";char c = str.charAt(2);System.out.println(c);//output: l 6.int compareTo(Object o)把这个字符串和另一个对象比较123456String str = \"Hello world\";String str1 = \"Good Friends\";int i = str.compareTo(str1);System.out.println(i);//output: 1 比较此对象与指定对象的顺序。如果该对象小于、等于或大于指定对象，则分别返回负整数、零或正整数。返回整数，1，-1,0；返回1表示大于，返回-1表示小于，返回0表示相等。 7.boolean endsWith(String str)测试此字符串是否以指定的后缀结束。123456String str = \"Hello World\";boolean b = str.endsWith(\"d\");System.out.println(b);//output:true 8.boolean equals(Object object)将此字符串与指定的对象比较1234String str = \"Hello World !\"; String str1 = \"Good Friends\";boolean b = str.equals(str1);System.out.println(b); 9.int indexOf(int char)返回指定字符在此字符串中第一次出现处的索引123456String str = \"Hello World !\";int i = str.indexOf('e');System.out.println(i);//output: 1//若无此字符串，则返回-1 更多String方法，点击查看 思考null和空字符串的区别s String s=null;string.trim()就会抛出为空的exceptionString s=””;string.trim()就不会抛,为什么? 答：1）null代表声明了一个空对象，根本就不是一个字符串，对空对象做任何操作都不行，除了 = 和 == ；“”代表声明了一个对象实例，这个对象实例的值是一个长度为0的空字符串，其仍代表一个字符串，只是字符串里面没有内容。2）String s = null;只是定义了一个句柄，也就是说你有了个引用，但是这个引用未指向任何内存空间；String s = “”;这个引用指向了一块是空字符串的内存空间，可对其进行满足字符串操作的任何操作。 所以，题目中为何一个会抛异常，一个不会抛异常就得以解答。 String s;和String s=null;和String s=”a”;有什么区别？ 针对这三种情况，使用out.println(s);的时候，第一个会出现异常，第二个会输出null.第三个则会输出a. 这是为什么呢？这三句声明语句，各自作了什么呢？ 答：第一个只是定义了一个String类型变量s，并没有给它赋值（若是类的成员变量，才默认赋值），在Java中，默认在使用一个对象的时候必须赋予它初值（降低风险）。第二个和第三个都定义了String类型变量s，并赋予它初值，只不过第二个赋予的值为null；Attention：s为一个引用，它不是对象。第一个是没有初始化的引用，第二个为空引用，第三个是在字符串池里写入一个字符’a’，然后s指向它。Ps：String s = ‘a’ ;和 String s = new String(“a”);是有本质上的区别的。前者是在字符串池里写入一个字符’a’，然后s指向它，后者是在堆上创建一个内容为’a’的字符串对象。 声明了一个string a;变量在以后的判断中，a==””和a==null有何不同? 答：如果没有给a赋过值，a == “” 会导致异常。在实际处理中，往往认为””和null代表相同的含义，即代表无值。此时，建议用如下语法：123if (a == null || a == \"\")&#123; //处理语句&#125; 如果a为null，则不会执行后面的判断，直接返回true。null是用来判断引用类型是否分配了存储空间，””是针对字符串的。所以如果没有给a赋过值，a == “”会导致异常。 String abc=null;String abc=””;String abc;三种写法有什么区别？ 答：1：创建一个空字符串对象，2：创建一个字符串为空的字符串对象。3：声明一个字符串对象，但并没有分配内存，而1，2已经分配了内存 tips：在成员变量的定义中,String s;等同于String s=null;而在本地变量(方法变量)的定义中,String s;不等同于String s=null;,这时要使用s必须显式地赋值。 还有一点要说明的是：只要是在方法在中定义变量都要显示赋初值，main()方法也不例外，而在方法之外编译器回自动赋初值。","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"wanglilin.github.io/categories/JavaSE/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"wanglilin.github.io/tags/Java基础/"},{"name":"JavaSE","slug":"JavaSE","permalink":"wanglilin.github.io/tags/JavaSE/"}]}]}